<chapter id="typesystem">
    <title>Type system</title>
    
    <para>Every value in a Ceylon program is an instance of a type that can be expressed 
    within the Ceylon language as a <emphasis>class</emphasis>. The language does not 
    define any primitive or compound types that cannot, in principle, be expressed within 
    the language itself.</para>
    
    <para>A class is a recipe for producing new values, called <emphasis>instances</emphasis>
    of the class (or simply <emphasis>objects</emphasis>), and defines the operations and 
    attributes of the resulting values. A class instance may hold references to other 
    objects, and has an identity distinct from these references.</para>
    
    <para>Each class declaration defines a type. However, not all types are classes. It 
    is often advantageous to write generic code that abstracts the concrete class of a 
    value. This technique is called <emphasis>polymorphism</emphasis>. Ceylon supports 
    two different kinds of polymorphism:</para>
    
    <itemizedlist>
        <listitem>
            <para><emphasis>subtype polymorphism</emphasis>, where a subtype <literal>B</literal>
            inherits a supertype <literal>A</literal>, and</para>
        </listitem>
        <listitem>
            <para><emphasis>parametric polymorphism</emphasis>, where a type definition 
            <literal>A&lt;T&gt;</literal> is parameterized by a <emphasis>generic type 
            parameter</emphasis> <literal>T</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon, like Java and many other object-oriented languages, supports a single
    inheritance model for classes. A class may directly inherit at most one other class, 
    and all classes eventually inherit, directly or indirectly, the class <literal>Void</literal>
    defined in the module <literal>ceylon.language</literal>, which acts as the root of 
    the class hierarchy.</para>
    
    <para>A truly hierarchical type system is much too restrictive for more abstract 
    programming tasks. Therefore, in addition to classes, Ceylon recognizes the following 
    kinds of type:</para>
    
    <itemizedlist>
        <listitem>
            <para>An <emphasis>interface</emphasis> is an abstract type schema that cannot
            itself be directly instantiated. An interface may define concrete members, but
            these members may not hold references to other objects. A class may inherit one 
            or more interfaces. An instance of a class that inherits an interface is also 
            considered an instance of the interface.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>generic type parameter</emphasis> is considered a type
            within the declaration that it parameterizes. In fact, it is an abstraction
            over many types: it generalizes the declaration to all types which could be 
            assigned to the parameter.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>produced type</emphasis> is formed by specifying arguments
            for the generic type parameters of a parameterized type.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>union type</emphasis> is a type to which each of an 
            enumerated list of produced types is assignable.</para>
        </listitem>
        <listitem>
            <para>An <emphasis>intersection type</emphasis> is a type which is assignable 
            to each of an enumerated list of produced types.</para>
        </listitem>
    </itemizedlist>
    
    <para>Although we often use the term <emphasis>parameterized type</emphasis> or even
    <emphasis>generic type</emphasis> to refer to a parameterized type definition, it is
    important to keep in mind that a parameterized type definition is not itself a type.
    Rather, it is a <emphasis>type constructor</emphasis>, a function that maps types 
    to types. Given a list of type arguments, the function yields a produced type.</para>
    
    <para>The Ceylon type system is much more complete than most other object oriented
    languages. In Ceylon, it's possible to answer questions that might at first sound
    almost nonsensical if you're used to languages with more traditional type systems. 
    For example:</para>
    
    <itemizedlist>
        <listitem>
            <para>What is the return type of a <literal>void</literal> method?</para>
        </listitem>
        <listitem>
            <para>What is the type of an local that may or may not hold a value of 
            type <literal>Element</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type of a parameter that accepts either a <literal>String</literal>
            or a sequence of <literal>String</literal>s?</para>
        </listitem>
        <listitem>
            <para>What is the type of a parameter that accepts values which are instances 
            of both <literal>Persistent</literal> and <literal>Printable</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type of a nonempty sequence of <literal>Integer</literal>s, 
            <literal>Float</literal>s, and <literal>String</literal>s?</para>
        </listitem>
        <listitem>
            <para>What is the type that represents methods that accept two <literal>Float</literal>
            values?</para>
        </listitem>
        <!--listitem>
            <para>What is the type of an expression that may be evaluated to produce
            a <literal>String</literal>?</para>
        </listitem-->
        <!--
        <listitem>
            <para>What is the type of a sequence of natural numbers of length <literal>n+1</literal>?</para>
        </listitem>
        -->
        <listitem>
            <para>What is the type that represents subclasses of <literal>Renderer</literal> 
            which must be provided at instantiation time with a function that accepts an 
            object and produces a <literal>String</literal>?</para>
        </listitem>
    </itemizedlist>
    
    <para>The answers, as we shall discover, are: <literal>Void</literal>, 
    <literal>Nothing|Element</literal>, <literal>String|String[]</literal>,
    <literal>Persistent&amp;Printable</literal>,
    <literal>Method&lt;Object,Void,Float,Float&gt;</literal>,
    <literal>Sequence&lt;Integer|Float|String&gt;</literal> and 
    <literal>Class&lt;Renderer,Callable&lt;String,Object&gt;&gt;</literal>.</para>
    
    <!--itemizedlist>
        <listitem>
            <para><literal>Void</literal>, </para>
        </listitem>
        <listitem>
            <para><literal>Nothing|T</literal></para>
        </listitem>
        <listitem>
            <para><literal>Method&lt;Void, Float, Float&gt;</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>Gettable&lt;String&gt;</literal>.</para>
        </listitem>
    </itemizedlist-->
    
    <para>It's important that there is always a unique "best" answer to questions
    like this in Ceylon. The "best" answer is called the <emphasis>principal type
    of an expression</emphasis>. Every other type to which the expression is 
    assignable is a supertype of the principal type.</para>
    
    <para>Thus, every legal Ceylon expression has a unique, computable, well-defined 
    type without reference to how the expression is used or to what type it is assigned.
    This is the case even when type inference or type argument inference is used.</para>
    
    <para>Neither this specification nor the internal implementation of the Ceylon 
    compiler itself use any kind of "non-denotable" types. Every type mentioned 
    here or inferred internally by the compiler has a representation within the 
    language itself. Thus, the programmer is never exposed to confusing error 
    messages referring to mysterious types that are not part of the syntax of the 
    language.</para>
    
    <para>The ability to represent types like <literal>Method</literal>, <literal>Class</literal>,
    and <literal>Callable</literal> within the type system, and to therefore write
    code that operates on instances of these types in a typesafe way is what makes
    Ceylon a <emphasis>higher order</emphasis> language.</para>
    
    <section id="identifiernaming">
        <title>Identifier naming</title>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase. Members, parameters and locals must be 
        named with an initial lowercase or underscore. A package name element is an
        all-lowercase identifier.</para>
        
        <programlisting>PackageName: PIdentifier</programlisting>
        <programlisting>TypeName: UIdentifier</programlisting>
        <programlisting>MemberName: LIdentifier</programlisting>
        
        <para>An underscore <literal>_</literal> is considered a lowercase letter.</para>
        
        <para>Ceylon defines three identifier namespaces:</para>
        
        <itemizedlist>
            <listitem>
                <para>classes, interfaces, and type parameters share a single 
                namespace,</para>
            </listitem>
            <listitem>
                <para>methods, attributes, and locals share a single namespace, and</para>
            </listitem>
            <listitem>
                <para>packages have their own dedicated namespace.</para>
            </listitem>
        </itemizedlist>
        
        <para>The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to.</para>
        
    </section>
      
    <section id="type">
        <title>Types</title>
    
        <para>A <emphasis>type</emphasis> or <emphasis>type schema</emphasis> is a name 
        (an initial uppercase identifier) and an optional list of type parameters, with 
        a set of:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute schemas,</para>
            </listitem>
            <listitem>
                <para>method schemas, and</para>
            </listitem>
            <listitem>
                <para>class schemas.</para>
            </listitem>
        </itemizedlist>
        
        <para>The attribute, method, and class schemas are called the 
        <emphasis>members</emphasis> of the type.</para>
        
        <para>Speaking formally:</para>
        
        <itemizedlist>
            <listitem>
                <para>An <emphasis>attribute schema</emphasis> is a name (an initial 
                lowercase identifier) with a type and mutability.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>method schema</emphasis> is a name (an initial lowercase 
                identifier) and an optional list of type parameters, with a type (often 
                called the <emphasis>return type</emphasis>) and a list of one or more 
                parameter lists.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>class schema</emphasis> is a type schema with a 
                parameter list.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>parameter list</emphasis> is a list of names (initial 
                lowercase identifiers) with types. The <emphasis>signature</emphasis> of 
                a parameter list is formed by discarding the names, leaving the list of 
                types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Speaking slightly less formally, we usually refer to an attribute, method, or 
        member class of a type, meaning an attribute schema, method schema or class schema
        that is a member of the type.</para>
        
        <section id="memberdistinctness">
            <title>Member distinctness</title>
        
        <para>Overloading is illegal in Ceylon. A type may not have:</para>
        
        <itemizedlist>
            <listitem>
                <para>two attributes with the same name,</para>
            </listitem>
            <listitem>
                <para>a method and an attribute with the same name,</para>
            </listitem>
            <listitem>
                <para>two methods with the same name, or</para>
            </listitem>
            <listitem>
                <para>two member classes with the same name.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section id="subtyping">
            <title>Subtyping</title>
        
        <para>A type may be a <emphasis>subtype</emphasis> of another type. Subtyping obeys 
        the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>Identity: <literal>X</literal> is a subtype of <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Transitivity: if <literal>X</literal> is a subtype of <literal>Y</literal>
                and <literal>Y</literal> is a subtype of <literal>Z</literal> then
                <literal>X</literal> is a subtype of <literal>Z</literal>.</para>
            </listitem>
            <listitem>
                <para>Noncircularity: if <literal>X</literal> is a subtype of <literal>Y</literal>
                and <literal>Y</literal> is a subtype of <literal>X</literal> then
                <literal>Y</literal> and <literal>X</literal> are the same type.</para>
            </listitem>
            <listitem>
                <para>Single root: all types are subtypes of the class <literal>Void</literal>
                defined in the module <literal>ceylon.language</literal>.</para>
            </listitem>
            <!--listitem>
                <para>Generic consistency: If <literal>Y</literal> is a parameterized type, and 
                a class or interface <literal>X</literal> is a subtype of both <literal>Y&lt;U&gt;</literal> 
                and <literal>Y&lt;V&gt;</literal> then either <literal>Y&lt;U&gt;</literal> is a 
                subtype of <literal>Y&lt;V&gt;</literal> or <literal>Y&lt;V&gt;</literal> is a 
                subtype of <literal>Y&lt;U&gt;</literal>.</para>
            </listitem-->
        </itemizedlist>
        
        <!--comment><para>Note: intersections and <literal>Bottom</literal> don't satisfy the last of 
        these rules.</para></comment-->
        
        <para>Every interface type is a subtype of the class <literal>Object</literal> 
        defined in <literal>ceylon.language</literal>.</para>
        
        <para>If <literal>X</literal> is a subtype of <literal>Y</literal>, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>variable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has an attribute with the same name, whose type is 
                assignable to the type of the attribute of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>variable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has a <literal>variable</literal> attribute with the 
                same name and the same type.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>Y</literal>, <literal>X</literal> has a 
                method with the same name, with the same number of parameter lists, with 
                the same signatures, and whose return type is assignable to the return type 
                of the method of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each member class of <literal>Y</literal>, <literal>X</literal>
                has a member class of the same name, with a parameter list with the same 
                signature, that is a subtype of the member class of <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Furthermore, we say that <literal>X</literal> is <emphasis>assignable</emphasis>
        to <literal>Y</literal>.</para>
        
        </section>
        
        <section id="uniontypes">
            <title>Union types</title>
            
        <para>For any types <literal>X</literal> and <literal>Y</literal>, the 
        <emphasis>union</emphasis>, or <emphasis>disjunction</emphasis>,
        <literal>X|Y</literal>, of the types may be formed. A union type is a supertype of 
        both of the given types <literal>X</literal> and <literal>Y</literal>, and an instance
        of either type is an instance of the union type.</para>
        
        <para>The union type constructor <literal>|</literal> is associative, so the union 
        of three types may be written <literal>X|Y|Z</literal>.</para>
            
        <programlisting>UnionType: IntersectionType ("|" IntersectionType)*</programlisting>
        
        <para>If <literal>X</literal> and <literal>Y</literal> are both subtypes of a third type 
        <literal>Z</literal>, then <literal>X|Y</literal> inherits all members of <literal>Z</literal>.</para>

        <programlisting>void write(String|Integer|Float printable) { ... }</programlisting>
        
        <para>Union types satisfy the following rules, for any types <literal>X</literal>,
        <literal>Y</literal>, and <literal>Z</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    Commutativity: <literal>X|Y</literal> is the same 
                    type as <literal>Y|X</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Associativity: <literal>X|(Y|Z)</literal> is the same 
                    type as <literal>(X|Y)|Z</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Simplification: if <literal>X</literal> is a subtype 
                    of <literal>Y</literal>, then <literal>X|Y</literal> 
                    is the same type as <literal>Y</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Subtypes: <literal>X</literal> is a subtype of 
                    <literal>X|Y</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Supertypes: if both <literal>X</literal> and 
                    <literal>Y</literal> are subtypes of <literal>Z</literal>, 
                    then <literal>X|Y</literal> is also a subtype of
                    <literal>Z</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>The following results follow from these rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    <literal>X|Bottom</literal> is the same  type as <literal>X</literal> 
                    for any type <literal>X</literal>, and
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>X|Void</literal> is the same type as <literal>Void</literal>
                    for any type <literal>X</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>Finally:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is covariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;|X&lt;V&gt;</literal> is a
                subtype of <literal>X&lt;U|V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is contravariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;|X&lt;V&gt;</literal> is a
                subtype of <literal>X&lt;U&amp;V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment>
        <para>TODO: We should probably support aliases for union types using a syntax something 
        like this:</para>
        <programlisting>type Printable = String | Integer | Float;</programlisting>
        </comment>
        
        </section>
        
        <section id="intersectiontypes">
            <title>Intersection types</title>
            
        <para>For any types <literal>X</literal> and <literal>Y</literal>, the 
        <emphasis>intersection</emphasis>, or <emphasis>conjunction</emphasis>,
        <literal>X&amp;Y</literal>, of the types may be formed. An intersection type is a subtype 
        of both of the given types <literal>X</literal> and <literal>Y</literal>, and any object
        which is an instance of both types is an instance of the union type.</para>
        
        <para>The union type constructor <literal>&amp;</literal> is associative, so the union 
        of three types may be written <literal>X&amp;Y&amp;Z</literal>.</para>
            
        <programlisting>IntersectionType: EntryType ("&amp;" EntryType)*</programlisting>
        
        <para>The intersection <literal>X&amp;Y</literal> inherits all members of both
        <literal>X</literal> and <literal>Y</literal>.</para>
        
        <programlisting>void store(Persistent&amp;Format&amp;IdentifiableObject object) { ... }</programlisting>
        
        <para>Intersection types satisfy the following rules, for any types <literal>X</literal>,
        <literal>Y</literal>, and <literal>Z</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    Commutativity: <literal>X&amp;Y</literal> is the same 
                    type as <literal>Y&amp;X</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Associativity: <literal>X&amp;(Y&amp;Z)</literal> is the same 
                    type as <literal>(X&amp;Y)&amp;Z</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Simplification: if <literal>X</literal> is a subtype 
                    of <literal>Y</literal>, then <literal>X&amp;Y</literal> 
                    is the same type as <literal>X</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Supertypes: <literal>X</literal> is a supertype of 
                    <literal>X&amp;Y</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Subtypes: if both <literal>X</literal> and 
                    <literal>Y</literal> are supertypes of <literal>Z</literal>, 
                    then <literal>X&amp;Y</literal> is also a supertype of
                    <literal>Z</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Distributivity over union: <literal>X&amp;(Y|Z)</literal> is the same 
                    type as <literal>(X&amp;Y)|(X&amp;Z)</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>The following results follow from these rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    <literal>X&amp;Bottom</literal> is the same type as <literal>Bottom</literal> 
                    for any type <literal>X</literal>, and
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>X&amp;Void</literal> is the same type as <literal>X</literal>
                    for any type <literal>X</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>Finally:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is covariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;&amp;X&lt;V&gt;</literal> is a
                supertype of <literal>X&lt;U&amp;V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is contravariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;&amp;X&lt;V&gt;</literal> is a
                supertype of <literal>X&lt;U|V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment>
        <para>TODO: We should probably support aliases for intersection types using a syntax 
        something like this:</para>
        <programlisting>type Storable = Persistent &amp; Format &amp; IdentifiableObject;</programlisting>
        </comment>
        
        </section>
        
        <section id="bottomtype">
            <title>The bottom type</title>
            
            <para>The special type <literal>Bottom</literal> represents:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the intersection of all types, or, equivalently</para>
                </listitem>
                <listitem>
                    <para>the empty set.</para>
                </listitem>
            </itemizedlist>
            
            <para><literal>Bottom</literal> is assignable to all other types, but has
            no instances.</para>
            
            <para>A reference to a member of an expression of type <literal>Bottom</literal>
            is always an error, since there can never be a receiving instance.</para>
            
            <para><literal>Bottom</literal> is considered to belong to the module
            <literal>ceylon.language</literal>. However, its definition is actually
            implemented directly in the compiler.</para>
            
            <para>Because of the restrictions imposed by Ceylon's mixin inheritance 
            model:</para>
            
            <itemizedlist>
            <listitem>
                <para>If <literal>X</literal> and <literal>Y</literal> are classes, and
                <literal>X</literal> is not a subclass of <literal>Y</literal>, and 
                <literal>Y</literal> is not a subclass of <literal>X</literal>, then
                the intersection type <literal>X&amp;Y</literal> is equivalent to 
                <literal>Bottom</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X</literal> is an interface, the intersection type 
                <literal>X&amp;Nothing</literal> is equivalent to <literal>Bottom</literal>.</para>
            </listitem>
            </itemizedlist>
            
            <comment><para>TODO: Should the name of this type be a keyword, perhaps
            <literal>bottom</literal>?</para></comment>
            
        </section>
        
        <section id="typeofaprogramelement">
            <title>Type of a program element</title>
        
        <para>Method, attribute, and parameter declarations usually declare a type. 
        Types are identified by the name of the type (a class, interface, or type 
        parameter), together with a list of type arguments if the type definition 
        specifies type parameters.</para>
        
        <programlisting>TypeNameWithArguments: TypeName TypeArguments?</programlisting>
        
        <para>If the type is a class or interface nested inside a containing class or 
        interface, the type must be fully qualified by its containing types, except when 
        used inside the body of a containing type.</para>
        
        <programlisting>Type: TypeNameWithArguments ("." TypeNameWithArguments)*</programlisting> <!-- | Subtype -->
        
        <para>If a type has type parameters or a sequenced type parameter, a type argument 
        list must be specified. If a type has no type parameters, and no sequenced type 
        parameter, no type argument list may be specified.</para>
        
        <programlisting>BufferedReader.Buffer</programlisting>
        <programlisting>Entry&lt;Integer,Element&gt;</programlisting>
        
        <para>The name of a type may not be qualified by the package name.</para>
        
        <comment><para>TODO: Should we introduce a special syntax for qualification of 
        identifiers by package name, for example, <literal>:ceylon:language:metamodel:Class</literal>? 
        This would also allow us to have metamodel references for packages. Using 
        <literal>.</literal> as a qualifier is not an option, since it would make 
        the grammar context-senstive like in Java.</para></comment>
        
        <!--
        <comment><para>TODO: Should we allow the abbreviation <literal>Sequence&lt;&gt;</literal>
        meaning <literal>Sequence&lt;Object&gt;</literal> for covariant types, and 
        <literal>Comparable&lt;&gt;</literal> meaning <literal>Comparable&lt;Bottom&gt;</literal>
        for contravariant types?</para></comment>
        -->
        
        </section>
        
        <section id="typeinference">
            <title>Type inference</title>
        
        <para>Certain declarations which usually require an explicit type may omit the type, 
        forcing the compiler to infer it, by specifying the keyword <literal>value</literal>
        or <literal>function</literal> where the type usually appears.</para>
                
        <para>Type inference is only allowed for block local declarations. The keywords
        <literal>value</literal> and <literal>function</literal> may not be combined with 
        the <literal>shared</literal> annotation. Nor may they may they be used to declare
        a toplevel method or attribute.</para>
        
        <programlisting>value names = people[].name;</programlisting>

        <programlisting>function parse(String text) {
    return text.tokens(" .!?,:;()\n\f\r\t");
}</programlisting>

        <para>Type inference is supported for declarations which are are referred to only by 
        statements and declarations that occur within the lexical scope of the declaration. 
        Type inference is not supported for <literal>shared</literal> declarations which may 
        be accessed from outside the body containing the declaration, or for declarations
        which are referred to by statements or declarations that occur earlier in the body
        containing of the declaration.</para>
        
        <!--
        <comment><para>TODO: Should we let you leave off the type arguments in the type
        of a local declaration? For example:</para>
        <programlisting>Sequence&lt;&gt; names = people[].name;</programlisting></comment>
        -->
        
        </section>
        
        <section id="typenameabbreviations">
            <title>Type name abbreviations</title>
        
        <para>Certain important types may be written using an abbreviated syntax.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>X?</literal> means <literal>Nothing|X</literal> for any 
                type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>X[]</literal> means <literal>Empty|Sequence&lt;X&gt;</literal> 
                for any type <literal>X</literal>,</para>
            </listitem>
            <!--
            <listitem>
                <para><literal>X[n]</literal> means <literal>BoundedSequence&lt;X,#n&gt;</literal> 
                for any type <literal>X</literal> and dimension <literal>n</literal>.</para>
            </listitem>
             -->
            <listitem>
                <para><literal>X->Y</literal> means <literal>Entry&lt;X,Y&gt;</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>X(Y,Z)</literal> means <literal>Callable&lt;X,Y,Z&gt;</literal>
                where <literal>Y, Z</literal> is a list of types of any length.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>EntryType: AbbreviatedType ("->" AbbreviatedType)?</programlisting>
        <programlisting>AbbreviatedType: Type (Abbreviation | ParameterTypes)*</programlisting>        
        <programlisting>Abbreviation: "?" | "[]"</programlisting>
        <programlisting>ParameterTypes: "(" ( UnionType ("," UnionType)* )? ")"</programlisting>
                
        <!--
        <programlisting>Abbreviation: "?" | "[]" | "[" dimension "]"</programlisting>
        -->
        
        <para>Abbreviations may be combined:</para>
        
        <programlisting>String?[] words = { "hello", "world", null };
String? firstWord = words[0];
String->Integer[] onetwo = "onetwo"->{1, 2};
Float[](Float x, Float[] xs) add = (Float x, Float[] xs) append(xs, x);</programlisting>
        
        <para>When a type appears in an expression, the abbreviations cannot be used (they 
        cannot be disambiguated from operator expressions).</para>
                
        <comment><para>TODO: Java lets you put the <literal>[]</literal> after the variable
        name. C requires that. Should we support/require this variation? It is consistent
        with how we declare functional parameters!</para></comment>
        
        </section>
        
    </section>
        
    <section id="inheritance">
        <title>Inheritance</title>
        
        <para>Subtyping is a static relationship between classes, interfaces, and type 
        parameters, produced through the use of <emphasis>inheritance</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>a class may <emphasis>extend</emphasis> another class,</para>
            </listitem>
            <listitem>
                <para>a class may <emphasis>satisfy</emphasis> one or more interfaces,</para>
            </listitem>
            <listitem>
                <para>an interface may <emphasis>satisfy</emphasis> one or more other interfaces,</para>
            </listitem>
            <!--listitem>
                <para>an interface may <emphasis>adapt</emphasis> a class and/or one or more 
                other interfaces,</para>
            </listitem-->
            <!--
            <listitem>
                <para>an interface may <emphasis>satisfy</emphasis> exactly one class,</para>
            </listitem>
            -->
            <listitem>
                <para>a type parameter may <emphasis>satisfy</emphasis> a class and/or one or 
                more interfaces or type parameters, or</para>
            </listitem>
            <listitem>
                <para>a type parameter may <emphasis>abstract</emphasis> a class, interface or 
                type parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a type declaration extends or satisfies <!--or adapts --> a type, we say 
        it <emphasis>inherits</emphasis> the type. Inheritance results in a relationship
        called <emphasis>invariant subtyping</emphasis> between produced types.</para>
        
        <itemizedlist>
        <listitem>
            <para>If a type <literal>X</literal> inherits a type <literal>Y</literal>, 
            then <literal>X</literal> is an invariant subtype of <literal>Y</literal>.</para>
        </listitem>
        <listitem>  
            <para>If a parameterized type <literal>X&lt;T&gt;</literal> inherits a type 
            <literal>Y</literal>, then the produced type <literal>X&lt;B&gt;</literal> 
            is an invariant subtype of <literal>Y</literal> for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>  
            <para>If a parameterized type <literal>X&lt;T&gt;</literal> inherits a 
            produced type <literal>Y&lt;T&gt;</literal> that depends upon the type
            parameter <literal>T</literal>, then the produced type <literal>X&lt;B&gt;</literal> 
            is an invariant subtype of the produced type <literal>Y&lt;B&gt;</literal> 
            formed by substituting <literal>B</literal> for <literal>T</literal> for 
            any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <para>If a type is an invariant subtype of a second type then it is a subtype
        of the second type.</para>
        
        <comment><para>TODO: these rules need to be formalized into the language of
        type constructors (functions from types to types).</para></comment>
        
        <para>Ceylon visually distinguishes between a list of types which represents a
        combination (intersection) of the types, and a list of types which represents a 
        choice between (union of) the types. An intersection is written as 
        <literal>X &amp; Y &amp; Z</literal>. A union is written as 
        <literal>X | Y | Z</literal>.</para>
        
        <section id="pii">
            <title>Principal instantiation inheritance</title>
            
            <para>If a class or interface <literal>A</literal> is a subtype of the types
            <literal>B&lt;X&gt;</literal> and <literal>B&lt;Y&gt;</literal> for some
            parameterized type <literal>B&lt;T&gt;</literal>, and types <literal>X</literal> 
            and <literal>Y</literal>, then <literal>A</literal> must also be a subtype of 
            <literal>B&lt;Z&gt;</literal> for some subtype <literal>Z</literal> of 
            <literal>X</literal> and <literal>Y</literal>.</para>
            
            <para>Or, equivalently, <literal>B&lt;T&gt;</literal> must not be invariant in 
            <literal>T</literal> and <literal>A</literal> must also be a subtype of:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>B&lt;X&amp;Y&gt;</literal> if <literal>B&lt;T&gt;</literal>
                    is covariant in <literal>T</literal>, or</para>
                </listitem>
                <listitem>
                    <para><literal>B&lt;X|Y&gt;</literal> if <literal>B&lt;T&gt;</literal>
                    is contravariant in <literal>T</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>It further follows that if <literal>X</literal> and <literal>Y</literal>
            are distinct types, and <literal>B&lt;T&gt;</literal> is invariant in 
            <literal>T</literal>, then the type <literal>B&lt;X&gt;&amp;B&lt;Y&gt;</literal>
            is the empty type <literal>Bottom</literal>.</para>
        
        </section>
        
    <section id="extendedclass">
        <title>Extension</title>
    
        <para>A class may extend another class, in which case the first class is a subtype
        of the second class and inherits its members.</para>
        
        <programlisting>ExtendedType: "extends" ("super" ".")? Type PositionalArguments</programlisting>
    
        <para>The <literal>extends</literal> clause must specify exactly one superclass. 
        If the superclass is a parameterized type, the <literal>extends</literal> clause 
        must specify type arguments. The <literal>extends</literal> clause must specify 
        arguments for the initializer parameters of the superclass.</para>
        
        <programlisting>extends Person(name, org)</programlisting>
        
        <para>A member class annotated <literal>actual</literal> may use the qualifier 
        <literal>super</literal> in the <literal>extends</literal> clause to refer to the 
        member class it refines. When the qualifier <literal>super</literal> appears, the
        following class name refers to a member class of the superclass of the class that
        contains the member class annotated <literal>actual</literal>.</para>
        
        <programlisting>extends super.Buffer()</programlisting>
        
        <comment><para>TODO: This doesn't work if the member class being refined belongs
        to an interface. A solution would be to let you rename the refined member class
        in an <literal>import</literal> statement. Another possibility would be to introduce
        a specialized syntax, for example something like 
        <literal>super(Reader).Buffer()</literal>.</para></comment>
        
        <para>
        The root class <literal>Void</literal> defined in <literal>ceylon.language</literal> 
        does not have a superclass.
        </para>
        
        <!--
        <para>A user-defined class must extend the class <literal>Object</literal> defined 
        in <literal>ceylon.language</literal> or one of its subclasses.</para>
        -->
        
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfaction</title>
       
        <para>The <literal>satisfies</literal> clause does double duty. It's used to 
        specify that a type is a subtype of an interface, and to specify upper bound
        type constraints.</para>
        
        <itemizedlist>
        <listitem>
        <para>A class or interface may satisfy one or more interfaces, in which case
        the class or interface is a subtype of the satisfied interfaces, and inherits 
        their members.</para>
        </listitem>
        <listitem>
        <para>A type parameter may satisfy one or more interfaces, optionally, a class,
        and optionally, another type parameter. In this case, the satisfied types are 
        interpreted as upper bound type constraints on arguments to the type 
        parameter.</para>
        </listitem>
        </itemizedlist>
        
        <programlisting>SatisfiedTypes: "satisfies" Type ("&amp;" Type)*</programlisting>
    
        <para>The <literal>satisfies</literal> clause may specify multiple types. If a 
        satisfied type is a parameterized type, the <literal>satisfies</literal> clause 
        must specify type arguments.</para>
        
        <programlisting>satisfies Sequence&lt;Element&gt; &amp; Collection&lt;Element&gt;</programlisting>
                
        <!--
        <comment><para>TODO: We could let a class or interface conditionally satisfy or 
        extend an interface, called a <emphasis>conditional supertype</emphasis>, depending 
        upon the argument of a type parameter.</para>
        
        <programlisting>ConditionalTypes: SatisfiedTypes Conditions</programlisting>
        
        <programlisting>Conditions: "if" "(" Condition ("&amp;&amp;" Condition)* ")"</programlisting>
        
        <para>A <emphasis>condition</emphasis> would be a list of upper bounds and metatype
        bounds applying to a type parameter of the class of interface.</para>
        
        <programlisting>Condition: TypeName (Metatypes SatisfiedTypes? | SatisfiedTypes)</programlisting>
        
        <para>The type parameter must be a covariant or invariant type parameter of
        the class or interface.</para>
        
        <programlisting>satisfies SequenceEquality&lt;T&gt; if (T satisfies Equality&lt;T&gt;)</programlisting>
        
        <para>Then a produced type for the class or interface would be a subtype of the
        conditional supertype if the type arguments satisfy the bounds specified by the 
        condition.</para>
        
        <programlisting><![CDATA[shared interface Sequence<out T>
        satisfies Iterable<T> &
                  Category &
                  Correspondence<Integer,T> & 
                  Sized
        satisfies ElementwiseEquality 
                  if (T satisfies Equality<IdentifiableObject>) {        
    ... 
}

shared interface ElementwiseEquality
        satisfies Equality<Sequence<IdentifiableObject>> &
                  Correspondence<Integer,IdentifiableObject> & 
                  Sized
        given T satisfies Equality<IdentifiableObject> {

    shared actual Boolean equals(Sequence<IdentifiableObject> that) {
        if (this.size!=that.size) { return false; }
        for (Integer i in 0..size-1) {
            if (this[i]!=that[i]) { return false; }
        }
        else {
            return true;
        }
    }

    shared actual Integer hash {
        Integer h:=0;
        for (Integer i in 0..size-1) {
            h^=this[i].hash;
        }
        return h;
    }
      
}]]></programlisting>
        
        <para>An even more flexible form of this, which allows "conditional members",
        would allow the following simplification to the above example:</para>
        <programlisting><![CDATA[shared interface Sequence<out T>
        satisfies Iterable<T> &
                  Category &
                  Correspondence<Integer,T> & 
                  Sized
        satisfies Equality<Sequence<IdentifiableObject>> 
                  if (T satisfies Equality<IdentifiableObject>) {        
    ... 

    shared actual Boolean equals(Sequence<IdentifiableObject> that) 
            if (T satisfies Equality<IdentifiableObject>) {
        if (this.size!=that.size) { return false; }
        for (Integer i in 0..size-1) {
            if (this[i]!=that[i]) { return false; }
        }
        else {
            return true;
        }
    }

    shared actual Integer hash 
            if (T satisfies Equality<IdentifiableObject>) {
        Integer h:=0;
        for (Integer i in 0..size-1) {
            h^=this[i].hash;
        }
        return h;
    }
      
}]]></programlisting>
        </comment>
        -->
        
    </section>
    
    <section id="cases">
        <title>Cases</title>
        
        <para>The <literal>of</literal> clause does triple duty. It's used to define
        self types and type families, algebraic types, and enumerated type constraints.</para>
        
        <itemizedlist>
        <listitem>
            <para>An interface or <literal>abstract</literal> class may optionally 
            specify an enumerated list of all its subtypes, in which case no other
            type may be a direct subtype of the interface or <literal>abstract</literal> 
            class.</para>
        </listitem>
        <listitem>
            <para>Likewise, a type parameter may specify an enumerated list of all
            types which it accepts as a type argument.</para>
        </listitem>
        <listitem>
            <para>An interface or <literal>abstract</literal> class may specify a 
            single type parameter of itself or of the immediately containing type.</para>
        </listitem>
        </itemizedlist>
        
        <para>A type declaration with an <literal>of</literal> clause is called an
        <emphasis>enumerated type</emphasis>.</para>
        
        <programlisting>CaseTypes: "of" CaseType ("|" CaseType)*</programlisting>
        
        <para>The <literal>of</literal> clause may specify multiple types, called
        <emphasis>cases</emphasis>.</para>
        
        <programlisting>CaseType: MemberName | Type</programlisting>
        
        <para>The compiler is able to infer certain subtyping relationships from the 
        types listed in the <literal>of</literal> clause.</para>
        
        <itemizedlist>
        <listitem>
            <para>If every case of a type <literal>X</literal> is an invariant suptype 
            of a type <literal>Y</literal>, then <literal>X</literal> is an invariant 
            subtype of <literal>Y</literal>.</para>
        </listitem>
        <listitem>  
            <para>If every case of a parameterized type <literal>X&lt;T&gt;</literal> 
            is an invariant suptype of a type <literal>Y</literal>, then the produced 
            type <literal>X&lt;B&gt;</literal> is an invariant subtype of <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>  
            <para>If every case of a parameterized type <literal>X&lt;T&gt;</literal> 
            is an invariant suptype of a produced type <literal>Y&lt;T&gt;</literal> 
            that depends upon the type parameter <literal>T</literal>, then the produced 
            type <literal>X&lt;B&gt;</literal> is an invariant subtype of the produced 
            type <literal>Y&lt;B&gt;</literal> formed by substituting <literal>B</literal> 
            for <literal>T</literal> for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
               
        <para>If there is exactly one case, and it is a type parameter, then:</para> 
        
        <itemizedlist>
            <listitem>
                <para>the declared type is considered a subtype of the type parameter
                within the body of the declaration,</para>
            </listitem>
            <listitem>
                <para>every produced type of the declared type is considered a subtype 
                of the type argument to the type parameter in the produced type, and</para>
            </listitem>
            <listitem>
                <para>every type which extends or satisfies a produced type of the 
                declared type must also directly or indirectly extend or satisfy the 
                type argument to the type parameter in the produced type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting><![CDATA[shared abstract class Comparable<Other>() of Other 
        given Other satisfies Comparable<Other> {
    
    shared formal Integer compare(Other that);
    
    shared Integer reverseCompare(Other that) {    
        return that.compare(this); //this is Other
    }
    
}]]></programlisting>
        
        <programlisting>Comparable&lt;Item&gt; comp = ... ;
Item item = comp;</programlisting>
    
        <para>Otherwise, there may be multiple cases, and each case is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a subtype of the interface or <literal>abstract</literal> 
                class, or</para>
            </listitem>
            <listitem>
                <para>the name specified in the <literal>object</literal> 
                declaration of a toplevel anonymous class that is a subtype of 
                the interface or <literal>abstract</literal> class.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>of larger | smaller | equal</programlisting>
        
        <programlisting>of Root&lt;Element&gt; | Leaf&lt;Element&gt; | Branch&lt;Element&gt;</programlisting>
        
        <para>An explicit list of cases allows safe use of a type in a 
        <literal>switch</literal> statement. The compiler is able to validate that 
        the <literal>switch</literal> contains an exhaustive list of all cases of 
        the type.</para>
        
        <comment><para>TODO: If all cases of an interface or class are subtypes of 
        a certain type, does the compiler automatically reason that the interface 
        or class is a subtype of that type?</para></comment>
        
        <para>Therefore, the <literal>of</literal> declaration is used to simulate 
        enumerated types and algebraic types.</para>
        
        <para>A class or interface may not be a subtype of more than one case of an 
        enumerated type.</para>
        
    </section>
    
    <section id="gadts">
        <title>PROPOSAL: Generalized algebraic types</title>
        
        <comment><para>NOTE: Generalized algebraic types are a proposed feature 
        for a future version of the language.</para></comment>
        
        <itemizedlist>
            <listitem>
                 <para>A <emphasis>simple algebraic datatype</emphasis> is a 
                 parameterized type <literal>A&lt;T&gt;</literal> with a list 
                 of cases where every case <literal>C&lt;T&gt;</literal> is 
                 parameterized by <literal>T</literal> and for every possible 
                 type argument <literal>X</literal> satisfying the constraints 
                 on <literal>T</literal> declared by <literal>A</literal>, 
                 <literal>C&lt;X&gt;</literal> is a legal produced type where 
                 <literal>X</literal> also satisfies the constraints on 
                 <literal>T</literal> declared by <literal>C</literal> and the
                 produced type <literal>C&lt;X&gt;</literal> is assignable to 
                 the produced type <literal>A&lt;X&gt;</literal>.</para>
            </listitem>
            <listitem>
                 <para>A <emphasis>generalized algebraic datatype</emphasis> is 
                 a parameterized type <literal>A&lt;T&gt;</literal> with a list 
                 of cases where either (a) at least one case is not parameterized 
                 by <literal>T</literal>&mdash;and is therefore assignable to 
                 <literal>A&lt;Y&gt;</literal> only for some values of the type 
                 argument <literal>Y</literal>, or (b) for at least one case
                 <literal>C&lt;X&gt;</literal> there is a type argument 
                 <literal>X</literal> satisfying the constraints on 
                 <literal>T</literal> declared by <literal>A</literal> where 
                 <literal>C&lt;X&gt;</literal> is not a legal produced type 
                 since <literal>X</literal> does not satisfy a constraint on 
                 <literal>T</literal> declared by <literal>C</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Given a parameterized type <literal>A&lt;T&gt;</literal>, a case 
        <literal>C&lt;T&gt;</literal> of <literal>A&lt;T&gt;</literal>, and a
        type argument <literal>X</literal> of <literal>T</literal>, we say that 
        <literal>C&lt;X&gt;</literal> is the <emphasis>produced case</emphasis> 
        of the produced type <literal>A&lt;X&gt;</literal>.</para>
        
        <para>The cases of a produced type <literal>A&lt;X&gt;</literal> for a 
        simple algebraic datatype <literal>A&lt;T&gt;</literal> and a type 
        argument <literal>X</literal> include exactly every produced case 
        <literal>C&lt;X&gt;</literal> for a case <literal>C&lt;T&gt;</literal> 
        of <literal>A&lt;T&gt;</literal>. Therefore, for every case of the simple 
        algebraic datatype <literal>A&lt;T&gt;</literal>, there is a corresponding 
        produced case of <literal>A&lt;X&gt;</literal>.</para>
        
        <para>On the other hand, the cases of a produced type <literal>A&lt;X&gt;</literal> 
        for a generalized algebraic datatype <literal>A&lt;T&gt;</literal> and a 
        type argument <literal>X</literal> include only the following:</para>
        
        <itemizedlist>
            <listitem>
                <para>every case <literal>C</literal> of <literal>A&lt;T&gt;</literal> 
                which is not parameterized by <literal>T</literal> and which is 
                assignable to <literal>A&lt;X&gt;</literal>, and</para>
            </listitem>
            <listitem>
                <para>every produced case <literal>C&lt;X&gt;</literal> for a
                case <literal>C&lt;T&gt;</literal> of <literal>A&lt;T&gt;</literal>
                which is a legal produced type where <literal>X</literal> satisfies
                all constraints on <literal>T</literal> declared by <literal>C</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>Therefore, for a given case of the generalized algebraic datatype 
        <literal>A&lt;T&gt;</literal>, there may be no corresponding case of 
        <literal>A&lt;X&gt;</literal>. In the extreme case that there is exactly 
        one case of the produced type <literal>A&lt;X&gt;</literal>, the compiler 
        treats the type <literal>A&lt;X&gt;</literal> as a type alias of that 
        unique case. Hence, <literal>A&lt;X&gt;</literal> may have members that
        are not part of the parameterized type schema <literal>A&lt;T&gt;</literal>.</para>
        
        <para>In the following example, the generalized algebraic datatype has 
        more than one case for each value of <literal>Value</literal>:</para>
        
        <programlisting><![CDATA[interface Expression<Value> 
        of Constant<Value> | Sum | Product | Conjunction | Disjunction
        given Value of Number | Boolean { ... }
        
class Constant<Value>(Value val) 
        extends Case($val)
        satisfies Expression<Value> 
        given Value of Number | Boolean { ... }

class Sum(Expression<Number>... terms) 
        satisfies Expression<Number> { ... }
class Product(Expression<Number>... terms) 
        satisfies Expression<Number> { ... }

class Conjunction(Expression<Boolean>... terms) 
        satisfies Expression<Boolean> { ... }
class Disjunction(Expression<Boolean>... terms) 
        satisfies Expression<Boolean> { ... }]]></programlisting>
        
        <para>Then <literal>Expression&lt;Number&gt;</literal> has the cases
        <literal>Sum</literal>, <literal>Product</literal> and 
        <literal>Constant&lt;Number&gt;</literal>, but 
        <literal>Expression&lt;Boolean&gt;</literal> has the cases
        <literal>Conjunction</literal>, <literal>Disjunction</literal> and 
        <literal>Constant&lt;Number&gt;</literal>.</para>
        
        <!--
        <para>The key here is that not every case listed in the <literal>of</literal>
        clause is valid for every possible value of the type parameter <literal>T</literal>. 
        Indeed, some cases do not even mention <literal>T</literal>, thus limiting 
        the case to exactly one possible value of <literal>T</literal>. This, the
        list of cases in a <literal>switch</literal> will depend upon the exact
        type argument to <literal>T</literal>.</para>
        
        <para>However, initially we can support only enumerated types and plain
        old algebraic types, simply by imposing the restriction that each case
        must include all the type parameters of the type.</para>
        
        <para>We can even use this as the basis for a kind of "conditional"
        subtyping:</para>
        -->
        
        <para>In this example, the generalized algebraic datatype has exactly 
        one case for each value of <literal>Value</literal>:</para>
        
        <programlisting><![CDATA[interface Expression<Value>
        of NumericExpression<Value> | BooleanExpression | StringExpression
        given Value of Number | Boolean | String { ... }
        
class NumericExpression<Value>
        satisfies Expression<Value>
        given Value satisfies Number { ... }

class BooleanExpression
        satisfies Expression<Boolean> { ... }

class StringExpression
        satisfies Expression<String> { 
    shared StringExpression uppercase { ... }
    shared StringExpression lowercase { ... }
    ...
}]]></programlisting>
        
        <para>Then the type <literal>Expression&lt;String&gt;</literal> has the
        attributes <literal>uppercase</literal> and <literal>lowercase</literal>,
        even though the parameterized type <literal>Expression&lt;Value&gt;</literal>
        does not declare these members.</para>
        
        <!--  
        <para>The compiler could reason that every <literal>Expression&lt;Integer&gt;</literal>
        is actually a <literal>NumericExpression&lt;Integer&gt;</literal>, that
        every <literal>Expression&lt;Boolean&gt;</literal> is actually a
        <literal>BooleanExpression</literal> without the need for explicit mention
        of the subtype.</para>
        -->
        
        <comment>
        <para>TODO: Actually, a potentially better syntax for GADTs would make the 
        conditions explicit:</para>
        
        <programlisting><![CDATA[interface Expression<Value> 
        of Constant<Number> | Sum | Product 
                if (Value satisfies Number)
        of Constant<Boolean> | Conjunction | Disjunction 
                if (Value satisfies Boolean)
        given Value of Number | Boolean { ... }]]></programlisting>
        </comment>
        
    </section>
    
    <section id="adaptedtypes">
        <title>PROPOSAL: Introduction</title>
        
        <comment><para>NOTE: Introductions are a proposed feature for a future 
        version of the language.</para></comment>
        
        <para>A toplevel interface may <emphasis>adapt</emphasis> a list of types, 
        in which case it is called an <emphasis>introduction</emphasis>. The types 
        are called <emphasis>adapted types</emphasis>.</para>
        
        <programlisting>AdaptedTypes: "adapts" Type ("&amp;" Type)*</programlisting>
                
        <para>The <literal>adapts</literal> clause may specify multiple types. If 
        a satisfied type is a parameterized type, the <literal>satisfies</literal> 
        clause must specify type arguments.</para>
        
        <programlisting>adapts Iterable&lt;Element&gt; &amp; Correspondence&lt;Integer,Element&gt;</programlisting>
        
        <para>Each adapted type must be class or interface. At most one adapted 
        type may be a class.</para>
        
        <para>An introduction <emphasis>introduces</emphasis> new types to every 
        type that is a subtype of all the adapted types in:</para>
        
        <itemizedlist>
            <listitem>
                <para>any compilation unit that imports the introduction, and</para>
            </listitem>
            <listitem>
                <para>the package to which the introduction belongs.</para>
            </listitem>
        </itemizedlist>
        
        <para>Specifically:</para>
        
        <itemizedlist>
        <listitem>
            <para>If a type <literal>X</literal> adapts a type <literal>Y</literal>, 
            then <literal>Y</literal> is an invariant subtype of <literal>X</literal> 
            in every compilation unit that imports <literal>X</literal> and in the 
            package to which <literal>X</literal> belongs.</para>
        </listitem>
        <listitem>  
            <para>If a parameterized type <literal>X&lt;T&gt;</literal> inherits a 
            type <literal>Y</literal>, then <literal>Y</literal> is an invariant 
            subtype of the produced type <literal>X&lt;B&gt;</literal> for any type 
            <literal>B</literal> in every compilation unit that imports 
            <literal>X</literal> and in the package to which <literal>X</literal> 
            belongs.</para>
        </listitem>
        <listitem>  
            <para>If a parameterized type <literal>X&lt;T&gt;</literal> inherits a 
            produced type <literal>Y&lt;T&gt;</literal> that depends upon the type
            parameter <literal>T</literal>, then the produced type <literal>Y&lt;B&gt;</literal> 
            formed by substituting <literal>B</literal> for <literal>T</literal> is 
            an invariant subtype of the produced type <literal>X&lt;B&gt;</literal> 
            for any type <literal>B</literal> in every compilation unit that imports 
            <literal>X</literal> and in the package to which <literal>X</literal> 
            belongs.</para>
        </listitem>
        </itemizedlist>
        
             <para>An introduction may not:</para>
             
             <itemizedlist>
                 <listitem>
                     <para>declare or inherit a member that refines a member of any 
                     adapted type, or</para>
                 </listitem>
                 <listitem>
                     <para>declare or inherit a <literal>formal</literal> or 
                     non-<literal>default</literal> <literal>actual</literal> member
                     unless the member is inherited from an adapted type.</para>
                 </listitem>
             </itemizedlist>
         
            <para>If, in a certain compilation unit, multiple introductions of a certain
            adapted type declare or inherit a member that refines a common member of a 
            common supertype then either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>there must be a unique member from the set of members, called the 
                    <emphasis>most refined</emphasis> member, that refines all the other 
                    members, or</para>
                </listitem>
                <listitem>
                    <para>the adapted type must declare or inherit a member that refines all 
                    the members.</para>
                </listitem>
            </itemizedlist>
            
            <para>At runtime, an operation (method invocation, member class instantiation, or 
            attribute evaluation) upon any type that is a subtype of all the adapted types is 
            dispatched according to the following rule:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If the runtime type of the instance of the adapted type declares 
                    or inherits a member defining the operation, the operation is dispatched 
                    to the runtime type of the instance.
                    </para>
                </listitem>
                <listitem>
                    <para>Otherwise, the operation is dispatched to the introduction that has 
                    the most-refined member defining the operation.
                    </para>
                </listitem>
            </itemizedlist>
            
    </section>
    
    <section id="metatypes">
        <title>PROPOSAL: Metatypes</title>
        
        <comment><para>NOTE: Metatypes are a proposed feature for a future version 
        of the language.</para></comment>
        
        <para>Metatype inheritance operates at the level of the metamodel.</para>
        
        <itemizedlist>
        <listitem>
        <para>The concrete metatype of a type <literal>T</literal> is the concrete 
        class of the object to which the expression <literal>T</literal> evaluates.
        The name of this class is not specified here. A class or interface may 
        optionally specify a list of additional <emphasis>metatypes</emphasis>, 
        interfaces satisfied by the concrete metatype of the type. A metatype may 
        not declare or inherit a <literal>formal</literal> member.</para>
        </listitem>
        <listitem>
        <para>A type constraint may specify a list of <emphasis>metatype bounds</emphasis> 
        which must be satisfied by the concrete metatype of the type argument.</para>
        </listitem>
        <listitem>
        <para>A class or method declaration may explicitly specify a 
        <emphasis>declared callable type</emphasis> satisfied by the callable type 
        of the class or method. The declared callable type must by a produced type
        for the parameterized type <literal>Callable</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <programlisting>Metatypes: "is" Type ("&amp;" Type)*</programlisting>
        
        <para>The <literal>is</literal> clause may specify multiple types, all of
        which must be interfaces.</para>
        
        <programlisting>is Monoid&lt;String&gt;</programlisting>
        
        <para>Metatypes and metatype bounds allow a function to operate polymorphically 
        over the metamodel object that represents a type. For example, a library could 
        define the following generic functionality:</para>
        
        <programlisting><![CDATA[shared interface Joinable<Value> {
    shared formal Value empty;
    shared formal Value join(Value x, Value y); 
}

shared Value join<Value>(Value... sequences)
        given Value is Joinable<Value> {
    Value result := Value.empty;
    for (Value s in sequences) {
        result := Value.join(result,s);
    }
    return result;
}]]></programlisting>

        <para>Which could be utilized as follows:</para>

<programlisting><![CDATA[shared interface JoinableLinkedList<Element> 
        satisfies Joinable<LinkedList<Element>> {
    shared actual LinkedList<Element> empty = LinkedList<Element>();
    shared actual LinkedList<Element> join(LinkedList<Element> x, LinkedList<Element> y) {
        return x.append(y);
    }
}

shared class LinkedList<Element>(Element... elements) 
        is JoinableLinkedList<Element> 
        satisfies List<Element> { ... }]]></programlisting>
        
        <para>A declared callable type constrains the types and parameter types of a 
        declaration. For example, given the following interface alias:</para>
        
        <programlisting>shared interface Page = Callable&lt;Html,HttpRequest&gt;;</programlisting>
        
        <para>We can explicitly specify the callable type of a method:</para>
        
        <programlisting>Html login(HttpRequest request) is Page { ... }</programlisting>
        
        <para>Or of a class:</para>
        
        <programlisting>class Login(HttpRequest request) is Page extends Html() { ... }</programlisting>
        
        <para>This style of declaration is useful when the method is going to be discovered 
        and invoked reflectively, without a direct dependency from the calling code. The
        compiler validates the full signature of the method or class against the declared 
        callable type.</para>
        
    </section>
        
    </section>

    <section id="generictypeparameters">
        <title>Generic type parameters</title>
    
        <para>Methods, class, and interface <!-- and type parameter --> declarations may be
        parameterized by one or more generic type parameters. A parameterized class or interface 
        declaration defines a type constructor, a function that produces a type given a tuple of 
        compatible type arguments. A parameterized class or method declaration defines a function 
        that produces the signature of an invokable operation given a tuple of compatible type
        arguments.</para>
        
        <programlisting>TypeParams: "&lt;" (TypeParam ",")* (TypeParam | SequencedTypeParam) "&gt;"</programlisting>
        
        <para>A declaration with type parameters is called <emphasis>generic</emphasis> or
        <emphasis>parameterized</emphasis>.</para>
        
        <itemizedlist>
        <listitem>
            <para>A type declaration with no type parameters defines exactly one type. A 
            parameterized type declaration defines a template for producing types: one type 
            for each possible combination of type arguments that satisfy the type constraints 
            specified by the type. The types of members of the this type are determined by 
            replacing every appearance of each type parameter in the schema of the 
            parameterized type definition with its type argument.</para>
        </listitem>
        <listitem>
            <para>A method declaration with no type parameters defines exactly one operation 
            per type. A parameterized method declaration defines a template for producing
            overloaded operations: one operation for each possible combination of type arguments 
            that satisfy the type constraints specified by the method declaration.</para>
        </listitem>
        <listitem>
            <para>A class declaration with no type parameters defines exactly one instantiation 
            operation. A parameterized class declaration defines a template for producing 
            overloaded instantiation operations: one instantiation operation for each possible 
            combination of type arguments that satisfy the type constraints specified by the 
            class declaration. The type of the object produced by an instantiation operation is 
            determined by substituting the same combination of type arguments for the type 
            parameters of the parameterized class.</para>
        </listitem>
        </itemizedlist>
        
        <!--
        <para>There are two kinds of type parameter:</para>
        
        <itemizedlist>
        <listitem>
            <para>an <emphasis>ordinary type parameter</emphasis> parameterizes the type by some
            other type, and</para>
        </listitem>
        <listitem>
            <para>a <emphasis>dimensional type parameter</emphasis> parameterizes the type by a
            natural number.</para>
        </listitem>
        </itemizedlist>
        -->
        
        <comment><para>Note: by convention, type parameter names should be constructed from
        meaningful words. The use of single-letter type parameter names is discouraged. The 
        name of a type parameter should be chosen so that declarations within the body of 
        the parameterized declaration read naturally. For example, 
        <literal>class Entry&lt;Key,Item&gt;</literal> is reasonable, since
        <literal>Key key</literal> and <literal>Item item</literal> read naturally within 
        the body of the <literal>Entry</literal> class. The following identifier names 
        usually refer to a type parameter: <literal>Element</literal>, <literal>Other</literal>, 
        <literal>Key</literal>, <literal>Item</literal>, <literal>Argument</literal> and 
        <literal>Result</literal>. Avoid, where reasonable, using these names for interfaces 
        and classes.</para></comment>
        
        <section id="typeparametersandvariance">
            <title>Type parameters and variance</title>
        
        <para>An <emphasis>ordinary type parameter</emphasis> allows a declaration to be 
        abstracted over a constrained set of types.</para>
        
        <programlisting>TypeParam: Variance? TypeName</programlisting>
        
        <para>Every ordinary type parameter has a name. A parameter of a class or interface 
        declaration has a specified <emphasis>variance</emphasis>.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>covariant</emphasis> type parameter is indicated using the
                keyword <literal>out</literal>.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>contravariant</emphasis> type parameter is indicated using the
                keyword <literal>in</literal>.</para>
            </listitem>
            <listitem>
                <para>By default, a type parameter is <emphasis>invariant</emphasis>.</para>
            </listitem>
        </itemizedlist>
        
        <para>An ordinary type parameter of a method declaration may not specify an explicit 
        variance and, for the purposes of this section, are considered invariant</para>
        
        <programlisting>Variance: "out" | "in"</programlisting>
        
        <para>Within the body of the declaration it parameterizes, an ordinary type parameter is 
        itself a type. The type parameter is a subtype of every upper bound of the type parameter. 
        However, a class or interface may not extend or satisfy a type parameter.</para>
        
        <programlisting>Map&lt;Key, out Item&gt;</programlisting>
        
        <programlisting>Sender&lt;in Message&gt;</programlisting>
        
        <programlisting>Container&lt;out Element&gt;</programlisting>
        
        <programlisting>BinaryFunction&lt;in Left, in Right, out Result&gt;</programlisting>
        
        <!--
        <comment><para>TODO: Would <literal>produces</literal> and <literal>consumes</literal> 
        be better?</para></comment>
        -->
        
        <para>A covariant type parameter may only appear in <emphasis>covariant positions</emphasis> 
        of the parameterized declaration. A contravariant type parameter may only appear in 
        <emphasis>contravariant positions</emphasis> of the parameterized declaration. Invariant 
        type parameters may appear in any position. As a special exception to this rule, any
        type parameter or a method or class may appear in any position in the parameter list of
        the method or class itself.</para>
        
        <para>Furthermore, a type with a contravariant type parameter may only appear in a
        covariant position in an extended type, satisfied type, case type, or upper bound
        type constraint.</para>
        
        <comment><para>Note: this restriction exists to eliminate certain undecidable cases
        described in Tate et al.</para></comment>
        
        <para>To determine if a type expression occurs in a covariant or contravariant position,
        we first consider how the type occurs syntactically.</para> 
        
        <para>In a method declaration:</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of the method is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A parameter type of the method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>Any upper bound of a type parameter of the method is a contravariant 
                position.</para>
            </listitem>
            <listitem>
                <para>Any lower bound of a type parameter of the method is a covariant 
                position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a simple attribute declaration not annotated <literal>variable</literal>,
        or an attribute getter declaration with no matching setter:</para>
        
        <itemizedlist>
            <listitem>
                <para>The type of the attribute is a covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a simple attribute declaration annotated <literal>variable</literal>, or
        an attribute getter declaration with a matching setter:</para>
        
        <itemizedlist>
            <listitem>
               <para>The type of the attribute is an invariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a class declaration:</para>
        
        <itemizedlist>
            <listitem>
                <para>An initializer parameter type of the class is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>Any upper bound of a type parameter of the class is a contravariant 
                position.</para>
            </listitem>
            <listitem>
                <para>Any lower bound of a type parameter of the class is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>An extended type, satisfied type, or case type is a covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In an interface declaration:</para>
        
        <itemizedlist>
            <listitem>
                <para>An extended type, satisfied type, or case type is a covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>For parameters of callable parameters, we first determine if the callable
        parameter itself is covariant or contravariant:</para>
        
        <itemizedlist>
            <listitem>
                <para>A callable parameter of a method or class is contravariant.</para>
            </listitem>
            <listitem>
                <para>A callable parameter of a covariant parameter is contravariant.</para>
            </listitem>
            <listitem>
                <para>A callable parameter of a contravariant parameter is covariant.</para>
            </listitem>
        </itemizedlist>
        
        <para>Then:</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of a covariant callable parameter is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>The return type of a contravariant callable parameter is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a parameter of a covariant callable parameter is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a parameter of a contravariant callable parameter is a 
                covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, to determine if a type parameter that occurs as a type argument occurs
        in a covariant or contravariant position, we must consider the declared variance
        of the corresponding type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument of a covariant type parameter of a type in a covariant 
                position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of a contravariant type parameter of a type in a 
                covariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of a covariant type parameter of a type in a 
                contravariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of a contravariant type parameter of a type in a 
                contravariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of an invariant type parameter of a type in any position 
                is an invariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of any type parameter of a type in an invariant position 
                is an invariant position.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>These rules apply to members declared by the type, and to members inherited from 
        supertypes.</para>
        -->
        
        </section>
        
        <section id="typeparametersandenumeratedtypes">
            <title>Type parameters and enumerated types</title>
        
        <para>If an enumerated type <literal>T&lt;X&gt;</literal> has a case type 
        which is a produced type of <literal>U</literal> then either:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>U</literal> is parameterized by a type parameter
                <literal>X</literal> and <literal>U&lt;X&gt;</literal> is an 
                invariant subtype of <literal>T&lt;X&gt;</literal>,
                </para>
            </listitem>
            <listitem>
                <para><literal>T&lt;X&gt;</literal> is covariant in <literal>X</literal>
                and <literal>U</literal> is an invariant subtype of 
                <literal>T&lt;Bottom&gt;</literal>, or</para>
            </listitem>
            <listitem>
                <para><literal>T&lt;X&gt;</literal> is contravariant in <literal>X</literal>
                and <literal>U</literal> is an invariant subtype of 
                <literal>T&lt;Void&gt;</literal>. 
                <emphasis>(TODO: should be the intersection of upper bounds.)</emphasis></para>
            </listitem>
        </itemizedlist>
        
        <para>If <literal>U&lt;X&gt;</literal> is a case of an enumerated type
        <literal>T&lt;X&gt;</literal>, then <literal>U&lt;X&gt;</literal> must be 
        an invariant subtype of <literal>T&lt;X&gt;</literal> and:</para>
        
        <itemizedlist>
            <listitem>
                <para>if <literal>T&lt;X&gt;</literal> is covariant in <literal>X</literal>
                then <literal>U&lt;Y&gt;</literal> must be covariant in <literal>Y</literal>, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>T&lt;X&gt;</literal> is contravariant in <literal>X</literal>
                then <literal>U&lt;Y&gt;</literal> must be contravariant in <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section id="sequencedtypeparameters">
            <title>Sequenced type parameters</title>
        
        <para>A <emphasis>sequenced type parameter</emphasis> allows a declaration to be 
        abstracted over a variable length list of arbitrary types. This allows declarations 
        with parameter lists to be represented by metamodel objects within the 
        language.</para>
        
        <para>A sequenced type parameter is identified by an elipsis <literal>...</literal>,
        indicating that it accepts a list of zero or more type arguments.</para>
        
        <programlisting>SequencedTypeParam: TypeName "..."</programlisting>
        
        <para>Sequenced type parameters are always non-variant.</para>
        
        <programlisting>ConcreteClass&lt;Value, Argument...&gt;</programlisting>
        <programlisting>Method&lt;Value, Result, Argument...&gt;</programlisting>
        <programlisting>Tuple&lt;Element...&gt;</programlisting>
        
        <para>Inside the declaration of the parameterized type or method, a sequenced type 
        parameter may be used as a type argument to other types which accept a sequenced 
        type parameter, or it may be used as the type of the last parameter declared by a 
        parameter list. It may not appear in any other position. The sequenced type 
        parameter acts as a pseudo-type. It is treated by the Ceylon compiler as if it were 
        a type with no members, to which no other type may be assigned, and which can only 
        by assigned to itself.</para>
        
        <comment><para>TODO: Should we let you declare a covariant sequenced type parameter?
        This is useful for modelling tuples. Should we allow you to declare a contravariant
        sequenced type parameter, and say that method parameter types are contravariant?</para></comment>
        
        <!--
        <comment><para>TODO: should we let you write things like:</para>
        <programlisting><![CDATA[class Foo<Element...>(Tuple<Bar<Element>...> barTup) {
    ...
    void baz(Baz<Element>... bazs) {
        ...
    }
}]]></programlisting>
        <para>It's probably only really useful if we also let you do stuff like this:</para>
        <programlisting><![CDATA[List<Result> zip<Result,Argument...>(List<Argument>... args, Result producing(Argument... args)) {
    return from (Integer i in 0..min(x.lastIndex...)) select (producing(args[i]...));
}]]></programlisting></comment>
        -->
        
        </section>
            
        <!--
        <section id="thesubtypekeyword">
            <title>PROPOSAL: The <literal>subtype</literal> keyword</title>
            
        <comment><para>NOTE: <literal>subtype</literal> is a proposed feature for a 
        future version of the language.</para></comment>
        
        <para>The keyword <literal>subtype</literal> is used to refer to the runtime 
        type of an object.</para>
            
        <programlisting>Subtype: "subtype" | MemberName "." "subtype"</programlisting>
        
        <para>Every class or interface has an implicit type parameter that never needs 
        to be declared. This special type parameter, referred to using the keyword 
        <literal>subtype</literal>, represents the runtime type of the current instance 
        (the instance that is being invoked). It is considered a covariant type parameter
        of the type, and may only appear in covariant positions of the type definition.
        It is upper bounded by the type (and is therefore assignable to the type).</para>
        
        <programlisting><![CDATA[shared interface Wrapper<out Value> {}]]></programlisting>
        
        <programlisting><![CDATA[shared abstract class Wrappable() {
   shared Wrapper<subtype> wrap() {
       return Wrapper(this);
   }
}]]></programlisting>
        
        <programlisting><![CDATA[shared class Special() extends Wrappable() {}]]></programlisting>

        <programlisting><![CDATA[Special special = Special();
Wrapper<Special> wrapper = special.wrap();]]></programlisting>

        <para>The only expression assignable to the type <literal>subtype</literal> is
        the self reference <literal>this</literal>, except inside the body of a method 
        or attribute annotated <literal>definite</literal>, where the class that declares 
        the method or attribute is assignable to <literal>subtype</literal>. 
        <emphasis>(Note that <literal>definite</literal> is a proposed feature for a 
        future version of the language.)</emphasis></para>
        
        <para>Every method has an implicit type parameter for each parameter of the
        method. For a method parameter <literal>x</literal>, the type parameter is
        referred to using the syntax <literal>x.subtype</literal>. This special type
        parameter represents the runtime type of the argument to the given parameter
        when the method is invoked. It is upper bounded by the declared type of the
        parameter (and is therefore assignable to the parameter type).</para>
        
        <programlisting><![CDATA[Entry<Name,x.subtype> named(String name, Object x) {
    return Name(name) -> x;
}]]></programlisting>
        
        <programlisting><![CDATA[Person gavin = Person("Gavin");
Entry<Name,Person> entry = named(gavin.name, gavin);]]></programlisting>
        
        <para>The only expression assignable to the type <literal>x.subtype</literal> 
        is the parameter <literal>x</literal> itself.</para>
        
        <comment><para>TODO: Should we allow you to refer to the concrete type of a
        refining member class in a subclass of the current class using the syntax
        <literal>subtype.MemberClass</literal>, to which the expression 
        <literal>MemberClass(...)</literal> is assignable? And/or the concrete type of 
        the containing class of a subtype of the current member class, using the syntax
        <literal>outer.subtype</literal>, to which <literal>outer</literal> is 
        assignable? Both would be considered implicit covariant type parameters.</para></comment>
        
        <comment><para>TODO: Should we let you declare type constraints on 
        <literal>subtype</literal>? The only really useful case I can think of would 
        be an initialization parameter constraint: <literal>given subtype(Foo foo, Bar bar)</literal>,
        which would let you do <literal>subtype(foo, bar)</literal> to instantiate a new
        instance of the concrete subclass of the current class, getting an expression
        of type <literal>subtype</literal>. Note that <literal>given subtype satisfies Foo</literal>
        (like a Scala "self type" declaration) is really not very different to declaring 
        the type <literal>satisfies Foo</literal>. Perhaps <literal>given subtype is 
        Metatype</literal> would be useful.</para>
        </comment>
        
        <comment><para>TODO: Are metatypes constrained so that if <literal>X satisfies Y</literal> 
        then <literal>X is Y</literal>? If so, then the type of <literal>y.type</literal> 
        as currently declared is not specific enough (it should be assignable to all 
        metatypes of Y). So if we do decide to add this constraint, then we should 
        probably merge together the keyword <literal>subtype</literal> with attribute
        <literal>Object.type</literal>, and get a new keyword, <literal>type</literal>,
        which can be used as <literal>subtype</literal> is currently used, or as a
        member, <literal>x.type</literal>.</para></comment>
        
        </section>
        -->
        
    <!--   
    <section id="dimensionaltypeparameters">
        <title>PROPOSAL: Dimensional type parameters</title>
            
        <comment><para>NOTE: dimensional type parameters are a proposed feature for a 
        future version of the language.</para></comment>
        
        <para>A dimensional type parameter allows a declaration to be abstracted over 
        the natural numbers.</para>
        
        <para>A dimensional type parameter is distinguished by an upper bound of the
        following form:</para>
        
        <programlisting>given N satisfies Dimension</programlisting>
        
        <para>Where the type <literal>Dimension</literal> represents the natural numbers:</para>
        
        <programlisting>shared interface Dimension of Zero | Successor&lt;Nat&gt; {}
shared interface Zero satisfies Dimension {}
shared interface Successor&lt;out N&gt; satisfies Dimension given N satisfies Dimension {}</programlisting>
        
        <comment><para>TODO: should we allow more specific constraints on dimensional 
        type parameters, for example <literal>given N&gt;=#1</literal>.</para></comment>
        
        <comment><para>TODO: should we let you declare <literal>X&lt;#n&gt;</literal>
        instead of <literal>X&lt;N&gt; given N satisfies Dimension</literal>, since
        actually the <literal>n</literal> is more useful than the <literal>N</literal>
        inside the declaration.</para></comment>
        
     </section>
     -->
     
     <section id="parameterizedtypeparameters">
        <title>PROPOSAL: Parameterized type parameters</title>

        <comment><para>NOTE: Parameterized type parameters is a proposed feature for a 
        future version of the language.</para></comment>
        
        <para>A <emphasis>parameterized type parameter</emphasis> is defined using a type
        constraint of form <literal>given X&lt;T&gt;</literal>, which specifies that the 
        type parameter is itself a parameterized type.</para>
            
        <programlisting>given Container&lt;Element&gt;(Element... elements) satisfies Iterable&lt;Element&gt;</programlisting>
    
        <para>The parameters of a parameterized type parameter may themselves have 
        constraints. These constraints are be defined in the same list of type
        constraints.</para>
        
        <para>A type argument to a parameterized type parameter must be a parameterized 
        type with type parameters to which the type parameters of the parameterized
        type parameter are assignable.</para>
        
        <para>A parameterized type parameter appears as a produced type (with type 
        arguments) in the body of the declaration.</para>
        
        <programlisting><![CDATA[Indirect<Key->Item> entry<Indirect<X>,Key,Item>(Indirect<Key> key, Indirect<Item> item) 
        given Indirect<X>(X x) satisfies Reference<X> {
    return Indirect(key.indirectedValue->item.indirectedValue);
}]]></programlisting>

        <para>Note that the argument to a parameterized type parameter is not, strictly
        speaking, a type. Rather, it is a parameterized type&mdash;a <emphasis>type
        constructor</emphasis>. For example, in the following, <literal>WeakReference</literal> 
        is viewed as a function from types <literal>Anything</literal> to produced types 
        <literal>WeakReference&lt;Anything&gt;</literal>:</para>
        
        <programlisting><![CDATA[WeakReference<Person> person = ... ;
WeakReference<Org> org = ... ;
//infers Indirect==WeakReference, Key==Person, Value==Org:
WeakReference<Person->Org> e = entry(person, org);]]></programlisting>
        
        <para>Parameterized type parameters allow functions to operate generically 
        over "container" types:</para>
                
        <programlisting><![CDATA[Many<Result> map<Many<X>,Argument,Result>(
            Result function(Argument arg), 
            Many<Argument> inputs)
        given Many<X>() satisfies Iterable<X> & Addable<X> {
    variable Many<Result> outputs := Many<Result>();
    for (Argument input in inputs) {
        outputs.=add(function(input));
    }
    return outputs;
}]]></programlisting>

        <programlisting>Set&lt;Person&gt; people = ... ;
Set&lt;String&gt; names = map(Person.name, people);</programlisting>

        <para>This effect can not even be achieved with metatypes. Even some cases
        which can be expressed using metatypes are more elegantly expressed using
        parameterized type parameters:</para>
        
        <programlisting><![CDATA[Many<Element> join<Many<X>,Element>(Many<Element>... sequences)
        given Many<X>(X... elements) satisfies Sequence<X> 
        given Element satisfies Object
        given X satisfies Object {
    return Many(joinSequences(sequences));
}]]></programlisting>
        
        <comment><para>Note: I think you can get most of the practical value by limiting 
        type constructor parameterization to methods only. Supporting type constructor 
        parameterization of classes and interfaces means that you have to be able to 
        reason about types whose arguments are type constructors. It seems to me that 
        you don't need to be able to do this if the feature is limited to methods. On the
        other hand, regularity argues for supporting both.</para></comment>
        
        <comment>
        <para>TODO: There are at least two other interesting functions which map types to 
        types:</para>
        <itemizedlist>
            <listitem>
                 <para>the identity type constructor <literal>id&lt;T&gt; == T</literal>, 
                 and</para>
            </listitem>
            <listitem>
                <para>constant type constructors (non-parameterized types), for 
                example, <literal>String&lt;T&gt; == String</literal>.</para>
            </listitem>
        </itemizedlist>
        <para>Should we allow these type constructors as arguments to a parameterized type 
        parameter?</para>
        
        <programlisting><![CDATA[Comparison compare<Many<X>,Other>(Many<Other> x, Many<Other> y)
        given Many<X> satisfies Sequence<X> | X
        given Other satisfies PartlyComparable<Other> {
    switch (Many<Other>)
    case (Other) {
        return x<=>y;
    }
    case (Sequence<Other>) {
        for (Integer i in 0..min(x.size,y.size)) {
            Comparison c = x[i]<=>y[i];
            switch (c)
            case (larger) {
                return larger;
            }
            case (smaller) {
                return smaller;
            }
            else {
                continue;
            }
        }
        return uncomparable;
    }
}]]></programlisting>

        <para>Note that <literal>given S&lt;X&gt; satisfies Sequence&lt;X&gt; | X</literal> is a way of writing
        <literal>given S&lt;X&gt; satisfies Sequence&lt;X&gt; | id&lt;X&gt;</literal>. A second example:</para>
        
        <programlisting><![CDATA[Many<Result> findByKey<Many<E>,Result,Key>(Type<Result> type, Many<Key> keys)
        given Many<E> of E | E[]
        given Key satisfies Object {
    ...
}]]></programlisting>
        <programlisting>Person p = findByKey(Person, personId);</programlisting>
        <programlisting>Order[] orders = findByKey(Order, orderIds);</programlisting>
        <programlisting><![CDATA[Result[] findManyByIntegerKey<Result>(Type<Result> type, Integer[] keys) = findByKey<Sequence,Result,Integer>;
Result findSingleByIntegerKey<Result>(Type<Result> type, Integer key) = findByKey<id,Result,Integer>;]]></programlisting>
<para>Or we could keep it simple :-)</para>
        </comment>
        
    </section>
    
    </section>

    <section id="generictypeconstraints">
    <title>Generic type constraints</title>

        <para>A parameterized method, class, or interface declaration may declare constraints 
        upon ordinary type parameters using the <literal>given</literal> clause.</para>
        
        <programlisting>TypeConstraints: TypeConstraint+</programlisting>
        
        <para>There may be at most one <literal>given</literal> clause per type parameter.</para>
        
        <programlisting>TypeConstraint: "given" TypeName TypeParams? Params? TypeConstraintInheritance</programlisting>
        
        <programlisting>TypeConstraintInheritance: CaseTypes? Metatypes? SatisfiedTypes? AbstractedType?</programlisting>
        
        <programlisting>AbstractedType: "abstracts" Type</programlisting>
        
        <!--
        <programlisting>ConcreteType: "this" "is"</programlisting>
       -->
        
        <para>Note that the syntax for a type constraint is essentially the same syntax 
        used for other type declarations such as class and interface declarations.</para>
        
        <para>There are five different kinds of type constraint:</para>
        
        <itemizedlist>
            <listitem>
                <para>an <emphasis>upper bound</emphasis>, <literal>given X satisfies T</literal>, 
                specifies that the type parameter <literal>X</literal> is a subtype of 
                a given type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>lower bound</emphasis>, <literal>given X abstracts T</literal>, 
                specifies that a given type <literal>T</literal> is a subtype of the 
                type parameter <literal>X</literal>,</para>
            </listitem>
            <!--listitem>
                <para>a subtype bound, <literal>X = subtype</literal>, specifies that 
                the type parameter <literal>X</literal> represents the concrete type
                of the current instance, and</para>
            </listitem-->
            <listitem>
                <para>an <emphasis>enumerated bound</emphasis>, <literal>given X of T|U|V</literal>
                specifies that the type parameter <literal>X</literal> represents one 
                of the enumerated types,</para>
            </listitem>
            <!--
            <listitem>
                <para>a <emphasis>concrete type bound</emphasis>, <literal>given this is X</literal>
                is permitted only for type parameters of parameterized interfaces and 
                <literal>abstract</literal> classes, and specifies that every concrete 
                subclass of the interface or <literal>abstract</literal> class is a 
                subtype of the argument to the type parameter <literal>X</literal>,</para>
            </listitem>
            -->
            <listitem>
                <para>a <emphasis>parameter bound</emphasis>, 
                <literal>given X(...)</literal> specifies that the type parameter 
                <literal>X</literal> is a concrete class with the given parameter types, 
                and</para>
            </listitem>
            <listitem>
                <para>a <emphasis>metatype bound</emphasis>, <literal>given X is T</literal>, 
                specifies that the concrete metatype of the type parameter is a subtype 
                of a given type <literal>T</literal>. <emphasis>(Note that metatypes are 
                a proposed feature for a future version of the language.)</emphasis></para>
            </listitem>
        </itemizedlist>
        
        <para>A constraint may not refer to a sequenced type parameter.</para>
        
        <para>A single <literal>given</literal> clause may specify multiple constraints
        on a certain type parameter. For example, it may specify multiple upper bounds
        together with a parameter bound. If multiple upper bounds are specified, at most
        one upper bound may be a class.</para>
        
        <programlisting><![CDATA[given Value(Integer n) satisfies IdentifiableObject & Comparable<Value>]]></programlisting>
        
        <programlisting><![CDATA[given Value satisfies Numberic<Value>
given Result(Integer count) satisfies Numeric<Result>]]></programlisting>
       
        <programlisting><![CDATA[given Quantities satisfies Correspondence<Key,Decimal>]]></programlisting>

        <programlisting><![CDATA[given Other satisfies Ordinal & Comparable<Other> abstracts Element]]></programlisting>
        
        <programlisting><![CDATA[given Value is Monoid<Value>]]></programlisting>
        
        <programlisting><![CDATA[given Argument of String | Integer | Float]]></programlisting>
        
        <comment><para>TODO: Should we let you declare a constraint for a sequenced type 
        parameter?</para>
        <programlisting>class Foo&lt;Argument...&gt;(Argument... args) 
        given Argument satisfies Comparable&lt;Argument&gt; {
    ...
}</programlisting></comment>

        <comment><para>TODO: Should we inherit generic type constraints from supertypes, 
        like in C#, or require them to be re-declared, like in Java?</para></comment>
            
    <section>
        <title>Upper bounds</title>
        
        <para>An upper bound constraint makes the type parameter assignable to the
        upper bound type, and allows operations of the upper bound type to be called
        upon expressions whose type is the type parameter.</para>
        
        <programlisting><![CDATA[class Holder<Value>(Value value) 
        extends Object
        given Value satisfies Object {
    shared Value value = value;
    shared actual Boolean equals(Object that) {
        if (is Holder<Value> that) {
            return value==that.value;
        }
    }
    shared actual Integer hash {
        return value.hash;
    }
}]]></programlisting>
        
        <para>Every type parameter has an implicit upper bound of type <literal>Void</literal>.</para>
                
    </section>
    
    <section>
        <title>Lower bounds</title>
        
        <para>A lower bound constraint makes the lower bound type assignable to the
        type parameter. The most common usecase is to work around the restriction that 
        a covariant type parameter may not appear in a contravariant position of the
        schema of the parameterized type.</para>
        
        <programlisting><![CDATA[shared class Set<out Element>(Element... elements)
        given Element satisfies Object {
    ...
     
    shared Set<UnionElement> union(Set<UnionElement> set)
            given UnionElement abstracts Element {
        return ...
    }
     
}]]></programlisting>

        <para>A type parameter of a declaration may not appear anywhere in any lower 
        bound constraint on any type parameter of the same declaration. It may appear
        in any constraint on any type parameter of a nested declaration.</para>
        
    </section>
            
    <section>
        <title>Enumerated bounds</title>
       
        <para>An enumerated bound allows the use of an exhaustive <literal>switch</literal>
        with expressions of the parameter type.</para>
        
        <programlisting><![CDATA[Characters uppercase<Characters>(Characters chars) 
       given Characters of String | Range<Character> { 
    switch (Characters)
    case (satisfies String) { 
        return chars.uppercased;
    }
    case (satisfies Range<Character>) { 
        return chars.first.uppercased..chars.last.uppercased;
    }
}]]></programlisting>

    </section>
    
    <section>
        <title>Parameter bounds</title>

        <para>A parameter bound allows instantiation of the type represented by the 
        type parameter within the body of the declaration.</para>
        
        <programlisting><![CDATA[Result create<Result>(Object object) 
        given Result(String s) { 
    return Result(object.string.lowercased);
}]]></programlisting>

    </section>
    
    <section>
        <title>PROPOSAL: Metatype bounds</title>
        
        <comment><para>NOTE: Metatypes are a proposed feature for a future version 
        of the language.</para></comment>
        
        <para>Note that an upper bound type constraint of form:</para>
        
        <programlisting>given X satisfies T</programlisting>
        
        <para>is equivalent to a metatype bound of this form:</para>
        
        <programlisting>given X is Type&lt;T&gt;</programlisting>
        
        <para>and that a parameter bound type constraint of form:</para>
        
        <programlisting>given X(A a, B b)</programlisting>
        
        <para>is equivalent to a metatype bound of this form:</para>
        
        <programlisting>given X is Callable&lt;X,A,B&gt;</programlisting>
        
        <comment><para>Note: I suppose that types introduced to the metatype should 
        be considered to satisfy a metatype bound, allowing type class introduction.
        </para></comment>
        
    </section>
    
    <section>
        <title>Generic type constraints and assignability</title>
            
        <para>Within the body of the declaration, a generic type constraint affects the 
        assignability of a type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type parameter is considered a subtype of its upper bound.</para>
            </listitem>
            <listitem>
                <para>The lower bound of a type parameter is considered a subtype of the
                type parameter.</para>
            </listitem>
            <listitem>
                <para>A metamodel reference to the type parameter is assignable to the
                metatype bound.</para>
            </listitem>
            <listitem>
                <para>A type parameter is considered a supertype of its enumerated type
                bounds.</para>
            </listitem>
            <!--
            <listitem>
                <para>A parameterized type is considered a subtype of any type parameter of 
                the type with a concrete type bound.</para>
            </listitem>
             -->
        </itemizedlist>
        
        </section>
    
    </section>
    
    <section id="generictypearguments">
        <title>Generic type arguments</title>
            
        <para>A list of <emphasis>type arguments</emphasis> produces a new type schema 
        from a parameterized type schema, or a new method schema from a method schema 
        with type parameters.</para>
        
        <para>A type argument list is a list of types and dimensions, and an optional 
        sequenced type argument.</para>
        
        <programlisting>TypeArguments: "&lt;" (UnionType ",")* (UnionType | SequencedType) "&gt;"</programlisting>
        <!-- 
        <programlisting>TypeArguments: "&lt;" (TypeArgument ",")* (TypeArgument | SequencedType) "&gt;"</programlisting>
        -->
        
        <para>A <emphasis>sequenced type argument</emphasis> is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a reference to a sequenced type parameter of the containing 
                declaration, or</para>
            </listitem>
            <listitem>
                <para>a <emphasis>sequenced type</emphasis>, which represents a 
                sequence of values of some specified type.</para>
            </listitem>
        </itemizedlist>
        
        <para>A sequenced type argument must appear last in the list of type arguments.</para>
                
        <programlisting>SequencedType: TypeName "..."</programlisting>
        
        <!-- 
        <para>A <emphasis>type argument</emphasis> is a type or a dimension:</para>
        
        <programlisting>TypeArgument: UnionType | Dimension</programlisting>
         -->
         
        <para>A type argument may itself be a parameterized type or type parameter.</para>
        
        <programlisting>Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        <programlisting>Entry&lt;String,Person?&gt;</programlisting>
        <programlisting>Stack&lt;Frame&gt;.Entry</programlisting>
        <programlisting>Callable&lt;Value,Result,Argument...&gt;</programlisting>
        <programlisting>Callable&lt;String[],Object...&gt;</programlisting>
        
        <!--
        <programlisting>Vector&lt;#10&gt;</programlisting>
        <programlisting>Matrix&lt;#x,#y&gt;</programlisting>
        -->
    
        <!--
        <section id="dimensions">
            <title>PROPOSAL: Dimensions</title>
        
            <comment><para>NOTE: dimensional type parameters are a proposed feature
            for a future version of the language.</para></comment>
        
        <para>A <emphasis>dimension</emphasis> is an expression composed of dimensional
        type parameters, natural number literals, locals of type <literal>Integer</literal>, 
        the operators <literal>+</literal> and <literal>*</literal>, and parentheses.</para>
        
        <programlisting>Dimension: DimensionTerm ("+" DimensionTerm)*</programlisting>
        <programlisting>DimensionTerm: (DimensionConstant "*")* DimensionAtom</programlisting>
        <programlisting>DimensionAtom: DimensionConstant | DimensionVariable | ParenDimension</programlisting>
        <programlisting>ParenDimension: "(" Dimension ")"</programlisting>
        
        <para>A <emphasis>dimensional type constant</emphasis> is an expression of form
        <literal>#c</literal> where <literal>c</literal> is a natural number literal.</para>
        
        <programlisting>DimensionConstant: "#" IntegerLiteral</programlisting>
        
        <para>A <emphasis>dimensional type variable</emphasis> is a dimensional type parameter, 
        or an expression of form <literal>#n</literal> where <literal>n</literal> is a local of 
        type <literal>Integer</literal>.</para>
        
        <programlisting>DimensionVariable: TypeName | "#" MemberName</programlisting>
        
        <para>The <emphasis>canonical form</emphasis> of a dimension expression is formed
        by algebraically simplifying the expression to a dimension expression of form:</para>
        
        <programlisting>#c + #n * N + #m * M + ...</programlisting>
        
        <para>where <literal>c</literal>, <literal>n</literal>, <literal>m</literal>, 
        <literal>...</literal> are constant natural numbers and <literal>N</literal>, 
        <literal>M</literal>, <literal>...</literal> are distinct dimensional type
        variables.</para>
        
        <para>Two dimension expressions are considered <emphasis>equivalent</emphasis> if 
        they have the same canonical form, ignoring the order of terms. For example, the
        following represent the same type:</para>
        
        <programlisting>Vector&lt;#2*N+#i+#3&gt;</programlisting>
        <programlisting>Vector&lt;(N+#2)+(#i+N+#1)&gt;</programlisting>
        
        <comment><para>Note: the <literal>#</literal> symbol acts almost like an operator 
        that accepts a value of type <literal>Integer</literal>, and returns a 
        <literal>Type&lt;Dimension&gt;</literal>, where <literal>#0 == Zero</literal>,
        <literal>#1 == Successor&lt;Zero&gt;</literal>, 
        <literal>#2 == Successor&lt;Successor&lt;Zero&gt;&gt;</literal>,
        etc.</para></comment>
        
        <comment><para>Note: we will provide a function that does the opposite and obtains 
        the <literal>Integer</literal> that corresponds to a dimensional type, something
        like: 
        <programlisting>shared Integer natural&lt;N&gt;() given N satisfies Dimension { ... }</programlisting></para></comment>
        
        <comment><para>TODO: should we allow ranges as arguments to dimensional type 
        parameters, for example, <literal>Vector&lt;#0...&gt;</literal> or
        <literal>Vector&lt;#1..#10&gt;</literal>, where <literal>Vector&lt;#c&gt;</literal>
        is a subtype of <literal>Vector&lt;#m..#n&gt;</literal> if 
        <literal>m&lt;=c&lt;=n</literal>. If so, we should also allow abbreviations 
        like <literal>String[1..n]</literal> for sequences.</para></comment>
        
        </section>
        -->
         
    <section>
        <title>Type arguments and type constraints</title>
    
        <para>A generic type constraint affects the type arguments that can be assigned 
        to a type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument to a type parameter with an upper bound must be a 
                type which is a subtype of all upper bounds.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with a lower bound must be a 
                type of which all lower bounds are subtypes.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with an enumerated type bound 
                must be a subtype of one of the enumerated types, or a type with an 
                enumerated subtype list that is a subset of the enumerated types of the 
                constraint.</para>
            </listitem>
            <!--
            <listitem>
                <para>A type argument to a type parameter with a concrete type bound must
                be a supertype of the type being declared when the parameterized type
                appears in a <literal>extends</literal> or <literal>satisfies</literal>
                clause.</para>
            </listitem>
            -->
            <listitem>
                <para>A type argument to a type parameter with an initialization parameter
                specification must be a class with the given initialization parameter
                types.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with a metatype bound must have 
                a metatype assignable to all metatype bounds. <emphasis>(Note that metatype 
                bounds are a proposed feature for a future version of the language.)</emphasis></para>
            </listitem>
        </itemizedlist>
    
    </section>
            
        <section id="typeargumentconformance">
            <title>Type argument conformance</title>
        
        <para>A type argument list <emphasis>conforms</emphasis> to a type parameter list 
        if:</para>
        
        <itemizedlist>
             <listitem>
                 <para>a type argument that satisfies the constraints of the type parameter 
                 is specified for every ordinary type parameter,</para>
             </listitem>
             <!--
             <listitem>
                 <para>a dimension is specified for every dimensional type parameter, and</para>
             </listitem>
             -->
             <listitem>
                 <para>if the type parameter list has no sequenced type parameter, then 
                 there are no additional type arguments, and no sequenced type argument.</para>
             </listitem>
        </itemizedlist>
        
        </section>
                
        <section id="producedtypes">
            <title>Produced types and and variance</title>
            
        <para>If a type argument list conforms to a type parameter list, the combination
        of the parameterized type together with the type argument list is itself a type,
        called a <emphasis>produced type</emphasis>.</para>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, the types 
        <literal>T&lt;A&gt;</literal> and <literal>T&lt;B&gt;</literal> represent the 
        same type if and only if <literal>A</literal> and <literal>B</literal> are the 
        same type.</para>
        
        <!--
        <para>For a generic type <literal>T&lt;n&gt;</literal>, the types 
        <literal>T&lt;a&gt;</literal> and <literal>T&lt;b&gt;</literal> represent the 
        same type if and only if <literal>a</literal> and <literal>b</literal> are 
        equivalent dimension expressions.</para>
        -->
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, a type <literal>A</literal>,
        and a subtype <literal>B</literal> of <literal>A</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If <literal>X</literal> is a covariant type parameter, 
                    <literal>T&lt;B&gt;</literal> is a subtype of <literal>T&lt;A&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is a contravariant type parameter, 
                    <literal>T&lt;A&gt;</literal> is a subtype of <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is invariant (neither covariant nor contravariant), 
                    there is no subtype relationship between <literal>T&lt;A&gt;</literal> and 
                    <literal>T&lt;B&gt;</literal> unless <literal>A</literal> and <literal>B</literal> 
                    are the same type.
                </para>
            </listitem>
        </itemizedlist>
        
        <comment><para>Note that if <literal>X</literal> is an invariant type parameter, 
        then a produced type <literal>S</literal> is a subtype of <literal>T&lt;A&gt;</literal> 
        if and only if <literal>S</literal> is an invariant subtype of 
        <literal>T&lt;A&gt;</literal>.</para></comment>
        
        <para>A produced type is a subtype of the type argument to any type parameter 
        that appears in the <literal>of</literal> clause of the type declaration. If 
        <literal>X</literal> is a type parameter of the parameterized type 
        <literal>T&lt;X&gt; of X</literal>, then <literal>T&lt;A&gt;</literal> is 
        assignable to <literal>A</literal> for every type argument <literal>A</literal> 
        which satisfies the other type constraints on <literal>X</literal>.</para>
        
        </section>
        
        <section id="qualifiedtypes">
            <title>Qualified types</title>
            
            <para>If a class or interface declaration <literal>X&lt;P1,P2,...&gt;</literal> 
            with type parameters <literal>P1,P2,...</literal> has a member class or interface 
            declaration <literal>M&lt;Q1,Q2,...&gt;</literal>, then:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>U.M&lt;A1,A2,...&gt;</literal> is a subtype of 
                    <literal>V.M&lt;B1,B2,...&gt;</literal> if <literal>U</literal> is a subtype 
                    of <literal>X&lt;C1,C2,...&gt;</literal> and <literal>V</literal> is an 
                    invariant subtype of <literal>X&lt;C1,C2,...&gt;</literal> and <literal>V</literal> 
                    directly inherits <literal>M</literal> from <literal>X</literal> without 
                    refining <literal>M</literal> and if <literal>M&lt;A1,A2,...&gt;</literal> 
                    is a subtype of <literal>M&lt;B1,B2,...&gt;</literal>.</para>
                </listitem>
                <listitem>
                    <para><literal>M&lt;A1,A2,...&gt;</literal>
                    is a subtype of <literal>V.M&lt;B1,B2,...&gt;</literal> if <literal>U</literal> 
                    is a subtype of <literal>X&lt;C1,C2,...&gt;</literal>and <literal>V</literal> 
                    is an invariant subtype of <literal>X&lt;P1,P2,...&gt;</literal> and <literal>V</literal> 
                    directly inherits <literal>M</literal> from <literal>X</literal> without 
                    refining <literal>M</literal> and if <literal>M&lt;A1,A2,...&gt;</literal> 
                    is a subtype of <literal>M&lt;B1,B2,...&gt;</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>Note that a type like <literal>M&lt;A1,A2,...&gt;</literal> is only
            well-formed inside the scope in which <literal>M</literal> is declared or imported.
            Outside this scope, references to <literal>M</literal> must be qualified by the 
            containing type.</para></comment>
            
        </section>
                
        <section id="typeargumentsubstitution">
            <title>Type argument substitution</title>
        
        <para>A type argument is substituted for every appearance of the corresponding
        type parameter in the schema of the parameterized declaration, including:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute types,</para>
            </listitem>
            <listitem>
                <para>method return types,</para>
            </listitem>
            <listitem>
                <para>method parameter types,</para>
            </listitem>
            <listitem>
                <para>initializer parameter types, and</para>
            </listitem>
            <listitem>
                <para>type arguments of extended classes and satisfied interfaces.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>A dimension is substituted for every appearance of the corresponding 
        dimensional type parameter in the schema of the parameterized declaration.
        The dimension appears as a parenthesized expression in expressions involving
        the dimensional type parameter.</para>
        -->
        
        <para>In the case of a sequenced type parameter:</para>
        
        <itemizedlist>
        <listitem> 
            <para>the type arguments are appended to the list of type arguments in every 
            parameterized type in which the sequenced type parameter appears, and</para>
        </listitem>
        <listitem> 
            <para>a list of parameters whose types are the type arguments is appended to 
            the list of parameters of every parameter list in which the sequenced type 
            parameter appears.</para>
        </listitem>
        </itemizedlist>
        
        <programlisting>Method&lt;Order, Item, Product, Integer&gt;</programlisting>
        
        <para>A sequenced type in a type argument list results in a sequenced parameter 
        in a parameter list.</para>
        
        <programlisting>Method&lt;String, Object...&gt;</programlisting>

        <para>A reference to a sequenced type parameter in a type argument list results 
        in a tuple parameter in a parameter list.</para>
        
        <programlisting>Method&lt;String, String, Argument...&gt;</programlisting>

        <comment><para>TODO: should we let you fill in the parameter names, so you can 
        call this thing using named arguments?
        <programlisting>Method&lt;Order, Item, Product prod, Integer quantity&gt;</programlisting>
        </para></comment>
        
        </section>
                
        <section id="reification">
            <title>Reification</title>
        
        <para>Type arguments are <emphasis>reified</emphasis> in Ceylon. An instance of a 
        generic type holds a reference to its type arguments. Therefore, the following are 
        legal in Ceylon:</para>
        
        <itemizedlist>
            <listitem>
                <para>testing the runtime value of a type argument of an instance, for 
                example, <literal>objectList is List&lt;Person&gt;</literal> or 
                <literal>case (is List&lt;Person&gt;)</literal>,</para>
            </listitem>
            <listitem>
                <para>filtering exceptions based on type arguments, for example,
                <literal>catch (NotFoundException&lt;Person&gt; pnfe)</literal>,</para>
            </listitem>
            <listitem>
                <para>testing the runtime value of an instance against a type parameter,
                for example <literal>x is Key</literal>, or against a type with a type 
                parameter as an argument, for example, 
                <literal>objectList is List&lt;Element&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing a type with 
                type arguments, for example, <literal>List&lt;Person&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing the runtime 
                value of a type parameter, for example, <literal>Element</literal>, or of 
                a type with a type parameter as an argument, for example, 
                <literal>List&lt;Element&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing the
                runtime value of a type argument of an instance using reflection, for 
                example, <literal>objectList.type.arguments.first</literal>, and</para>
            </listitem>
            <listitem>
                <para>instantiating a type parameter with an initialization parameter
                specification, for example, <literal>Result(parent)</literal>.</para>
            </listitem>
            <!--
            <listitem>
                <para>obtaining the numeric value of a dimensional type parameter, for
                example, <literal>for (Integer i in 0..natural&lt;N&gt;())</literal>.</para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>Sequenced type parameters are not reified. None of the above operations can 
        be performed with a sequenced type parameter.</para>
        
        <!--
        <para>The implicit type parameter <literal>subtype</literal> evaluates to the 
        concrete type of the current instance, as determined at runtime. Likewise, an 
        implicit type parameter of form <literal>x.subtype</literal> evaluates to the 
        concrete type of the method argument <literal>x</literal>, as determined at runtime. 
        This is different to other type parameters which reify to the type argument 
        determined at compile time. <emphasis>Note that support for the <literal>subtype</literal>
        keyword is a proposed feature for a future version of the language.</emphasis></para>
        -->
        
        </section>
        
        <!--
        <section id="subtypetypeargument">
            <title>PROPOSAL: The type argument of <literal>subtype</literal></title>
            
        <comment><para>NOTE: <literal>subtype</literal> is a proposed feature for a 
        future version of the language.</para></comment>
        
        <para>Any type schema in which the special type parameter <literal>subtype</literal> 
        occurs is considered a parameterized type. Any occurrence of the type is considered 
        a produced type, where the type argument to the type parameter <literal>subtype</literal> 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>the special type <literal>x.subtype</literal>, if the produced type 
                occurs in the declaration of a method parameter <literal>x</literal>, or</para>
            </listitem>
            <listitem>
                <para>the type itself, otherwise.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in principle the type argument to <literal>subtype</literal> is 
        always the runtime type of the instance. However, except in the special case of
        a method argument, there is no syntax for referring to this type.</para>
        
        <para>Any method schema in which the special type parameter <literal>x.subtype</literal> 
        occurs is considered a parameterized method schema. The type argument to the type 
        parameter <literal>x.subtype</literal> is:</para>
        
        <itemizedlist>
            <listitem>
                <para>the special type <literal>y.subtype</literal>, if the argument to
                <literal>x</literal> is a method parameter <literal>y</literal>, or</para>
            </listitem>
            <listitem>
                <para>the statically determined type of the method argument, otherwise.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in principle the type argument to <literal>x.subtype</literal> is 
        always the runtime type of the argument. However, except in the special case of
        a method argument, there is no syntax for referring to this type.</para>
        
        <comment><para>TODO: Actually, a better way to define this stuff might be to say
        that the type <literal>x.subtype</literal> is a legitimate type for any expression
        <literal>x</literal>, but then severely restrict the use of such types in declaration 
        schemas.</para></comment>
        
        </section>
        -->
    
        <section id="typeargumentinference">
            <title>Type argument inference</title>
        
        <para>When a direct invocation expression for a generic method or a direct 
        instantiation expression for a generic class does not explicitly specify type 
        arguments, the type arguments are inferred from the argument expression types. 
        The types of the argument expressions and the declared types of the 
        corresponding parameters determine an <emphasis>inferred lower bound</emphasis> 
        for each type parameter.</para>
        
        <para>If a list of argument expressions has types <literal>A1,A2,...</literal> 
        and the corresponding list of parameters has declared types <literal>P1,P2,...</literal>, 
        the inferred lower bound for a type parameter <literal>T</literal> of the generic
        declaration is the conjunction of:</para>
        
        <itemizedlist>
            <listitem>
                <para>the lower bound <literal>X</literal> explicitly declared by a type 
                constraint on <literal>T</literal> of form <literal>given T abstracts X</literal>, 
                if any, with</para>
            </listitem>
            <listitem>
                <para>all inferred lower bounds <literal>Ai</literal> on <literal>Pi</literal> 
                for <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Given types <literal>A</literal> and <literal>P</literal>, we determine 
        the <emphasis>inferred lower bound</emphasis> <literal>A</literal> on 
        <literal>P</literal> for <literal>T</literal> according to the nature of 
        <literal>A</literal> and <literal>P</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>P</literal> is exactly <literal>T</literal>, the 
                inferred lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is <literal>T abstracts A</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is a union type <literal>Q|R</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the disjunction of the lower bound 
                <literal>A</literal> on <literal>Q</literal> for <literal>T</literal> 
                with the lower bound <literal>A</literal> on <literal>R</literal> 
                for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is an intersection type <literal>Q&amp;R</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the conjunction of the lower bound 
                <literal>A</literal> on <literal>Q</literal> for <literal>T</literal> 
                with the lower bound <literal>A</literal> on <literal>R</literal> 
                for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>A</literal> is a union type <literal>B|C</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the conjunction of the lower bound <literal>B</literal> 
                on <literal>P</literal> for <literal>T</literal> with the lower bound 
                <literal>C</literal> on <literal>P</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>A</literal> is an intersection type <literal>B&amp;C</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the disjunction of the lower bound <literal>B</literal> 
                on <literal>P</literal> for <literal>T</literal> with the lower bound 
                <literal>C</literal> on <literal>P</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is a produced type <literal>Q&lt;P1,P2,...&gt;</literal> 
                of a parameterized type <literal>Q</literal>, and <literal>A</literal> 
                is a subtype of a produced type <literal>Q&lt;A1,A2,..&gt;</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the conjunction of all lower bounds <literal>Ai</literal> 
                on <literal>Pi</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>Otherwise, if <literal>A</literal> is not a union or intersection, 
                and if <literal>P</literal> is neither a produced type, a union, or an
                intersection, nor exactly <literal>T</literal>, the lower bound 
                <literal>A</literal> on <literal>P</literal> for <literal>T</literal>
                is <emphasis>null</emphasis>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Where:</para>
        
        <itemizedlist>
            <listitem>
                <para>the conjunction a lower bound <literal>T abstracts A</literal>
                with a lower bound <literal>T abstracts B</literal> is the lower bound 
                <literal>T abstracts A|B</literal>,</para>
            </listitem>
            <listitem>
                <para>the disjunction a lower bound <literal>T abstracts A</literal>
                with a lower bound <literal>T abstracts B</literal> is the lower bound 
                <literal>T abstracts A&amp;B</literal>,</para>
            </listitem>
            <listitem>
                <para>the conjunction or disjunction of a lower bound <literal>T abstracts A</literal>
                with a null lower bound is <literal>T abstracts A</literal>, and</para>
            </listitem>
            <listitem>
                <para>the conjunction or disjunction of two null lower bounds is null.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <comment><para>Note that the basis for this algorithm is:</para>
<programlisting>T abstracts A &amp;&amp; T abstracts B => T abstracts A|B</programlisting>
<programlisting>T abstracts A || T abstracts B => T abstracts A&amp;B</programlisting></comment>
        -->
        
        <!--        
        <comment><para>TODO: This incorrectly describes the algorithm used by the 
        actual compiler for union and intersection types. Actually what happens is 
        that the compiler always reduces any union or intersection type to a simplest 
        canonical form. This affects the result of the algorithm in some very rare 
        cases, due to the weirdness of the fourth and fifth rules. (In which case 
        the compiler's approach is better!)</para></comment>
        -->
        
        <comment><para>TODO: This does not do justice the the compiler's handling 
        of type parameters which have upper bounds involving other type parameters.
        In fact, the compiler is also able to infer a type for the type parameter 
        that appears in the upper bound.</para></comment>
        
        <!--
        <para>The <emphasis>full lower bound for an inferred type parameter</emphasis> 
        <literal>T</literal> of the generic declaration is the union of the lower 
        bound for <literal>T</literal> with the lower bound specified by each
        type constraint on <literal>T</literal> of form <literal>T abstracts X</literal> 
        for every lower bound <literal>X</literal> on <literal>T</literal> in the 
        generic type constraints on <literal>T</literal> (after substitution of 
        type arguments into <literal>X</literal>).</para>
        -->
        
        <para>The inferred type argument to a type parameter <literal>T</literal> 
        of the generic declaration is:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Bottom</literal>, if the inferred lower bound for 
                <literal>T</literal> is null, or, otherwise,</para>
            </listitem>
            <listitem>
                <para>the type <literal>A</literal>, where the inferred lower bound for 
                <literal>T</literal> is <literal>T abstracts A</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If the inferred type argument does not satisfy the generic type 
        constraints on <literal>T</literal>, a compilation error results.</para>
        
        <para>Consider the following invocation:</para>
        
        <programlisting><![CDATA[Element[] prepend<Element>(Element head, Element[] sequence) { ... }
value result = prepend(null, {"hello", "world"});]]></programlisting>

        <!--
        <para>The constraint set for <literal>Element</literal> comprises two 
        constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Element abstracts Nothing</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>Element abstracts String</literal>.</para>
            </listitem>
        </itemizedlist>
        -->
        
        <para>The inferred type of <literal>Element</literal> is the union type 
        <literal>String?</literal>.</para>
        
        <para>Now consider:</para>
        
        <programlisting><![CDATA[class Bag<out Element>(Element... elements) {
    shared Bag<ExtraElement> with<ExtraElement>(ExtraElement... elements) 
            given ExtraElement abstracts Element { ... }
}
Bag<String> bag = Bag("hello", "world");
value biggerBag = bag.with(1, 2, 5.0);]]></programlisting>
        
        <!--
        <para>The constraint set for <literal>ExtraElement</literal> comprises 
        three constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>ExtraElement abstracts Integer</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>ExtraElement abstracts Float</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>ExtraElement abstracts String</literal> (formed by
                substituting <literal>String</literal> for <literal>Element</literal>
                in the schema of <literal>Bag</literal>).</para>
            </listitem>
        </itemizedlist>
        -->
        
        <para>The inferred type of <literal>ExtraElement</literal> is the union 
        type <literal>Integer|Float|String</literal>.</para>
                
        <comment><para>TODO: What about lower bounds in which the type parameter 
        itself appears (the infamous self-type problem with
        <literal>Comparable</literal> and <literal>Numeric</literal>) or in which 
        another type parameter appears?</para></comment>
        
        <comment><para>TODO: This algorithm works fine for type parameters that 
        appear covariantly in the parameter types, and even okay for type
        parameters that appear nonvariantly. It doesn't really work very well 
        for type parameters that appear contravariantly, where the constraints
        are really of form <literal>A satisfies T</literal>, and they should be
        combined using intersection, not union, and where the default should be
        <literal>Object</literal> not <literal>Bottom</literal>. Unfortunately
        we don't currently support intersection types in the spec, or have the 
        machinery to reason about them in the compiler.</para>
        <para>Note also that there is something a bit conceptually funny about 
        a type parameter that appears covariantly in a parameter type, and 
        contravariantly in the return type (or vice-versa), so we probably don't 
        really need to bother about the case where a type parameter appears both 
        covariantly <emphasis>and</emphasis> contravariantly.</para></comment>
                
        </section>
        
    </section>
    
    <section id="parameters">
        <title>Parameters</title>
    
        <para>A method or class declaration may declare a list or <emphasis>parameters</emphasis>, 
        including, optionally:</para>
        
        <itemizedlist>
            <listitem>
                <para>one or more <emphasis>defaulted parameters</emphasis> (parameters with 
                default values), and/or</para>
            </listitem>
            <listitem>
                <para>a <emphasis>sequenced parameter</emphasis> (a "vararg" parameter).</para>
            </listitem>
        </itemizedlist>
        
        <para>In a parameter list, parameters with default values must occur after required 
        parameters. The sequenced parameter, if any, must occur last.</para>
        
        <programlisting>Params: 
"("
Param ("," Param)* ("," DefaultParam)* ("," SequencedParam)? | 
DefaultParam ("," DefaultParam)* ("," SequencedParam)? | 
SequencedParam?
")"</programlisting>

        <para>Each parameter is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>declared with an explicit type and name and may have annotations and/or 
                parameters of its own, or</para>
            </listitem>
            <listitem>
                <para>a named reference to a forward-declared simple attribute, local, or 
                method that directly occurs in the body that immediately follows the parameter 
                list.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Param: Annotation* (SimpleParam | CallableParam | EntryParamPair) | MemberName</programlisting>
        
        <programlisting>SimpleParam: UnionType MemberName</programlisting>
        
        <!--para>A parameter may not be be declared <literal>variable</literal>, and may not be 
        assigned to within the body of the method or class.</para-->
                
        <para>In the case of a reference, the name of the parameter must be the name of a 
        forward-declared simple attribute, local, or method of the method or class it 
        parameterizes, and the type of the parameter is the type of this simple attribute or 
        local, or the callable type of the method. Any argument to the parameter is used as the 
        specification of the value of the attribute or local to which it refers, or as the 
        implementation of the method to which it refers.</para>
        
        <programlisting>class Person(name, age=0) {
    shared String name;
    shared variable Integer age;
}</programlisting>
        
        <section id="callableparameters">
            <title>Callable parameters</title>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>callable parameter</emphasis>.</para>
        
        <programlisting>CallableParam: (UnionType | "void") MemberName Params+</programlisting>
        
        <para>Think of this as an abstract local method that must be defined by the caller 
        when the method is invoked or the class is instantiated.</para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(Value x, Value y))</programlisting>
        
        <para>A callable parameter declaration is equivalent to a parameter declaration with 
        no parameter lists where the type is the callable type of the method declaration. So 
        the above are equivalent to:</para>
        
        <programlisting>(String label, Callable&lt;Object&gt; onClick)</programlisting>
        
        <programlisting>(Callable&lt;Comparison,Value,Value&gt; by)</programlisting>
        
        </section>
        
        <section id="defaultedparameters">
            <title>Defaulted parameters</title>
        
        <para>Defaulted parameters specify a default argument.</para>
    
        <programlisting>DefaultParam: Param Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate 
        a value which cannot be reassigned.</para>
        
        <programlisting>Specifier: "=" (Expression | Function)</programlisting>
        
        <para>Defaulted parameters must occur after non-defaulted parameters in the parameter 
        list.</para>
        
        <programlisting>(Product product, Integer quantity=1)</programlisting>
        
        <para>The type of the default argument expression must be assignable to the declared
        type of the parameter.</para>
        
        <!--
        <para>If the declared type of the parameter is an optional type (a subtype of
        <literal>Nothing</literal>) then the default argument expression must be a value
        reference to <literal>null</literal>.</para>
        -->
        
        <para>A parameter of a method or class annotated <literal>actual</literal> may not 
        specify a default argument.</para>
        
        <para>A parameter of a method or class annotated <literal>actual</literal> inherits 
        the default argument, if any, if the corresponding parameter of the method it 
        refines.</para>
        
        <para></para>
        
        </section>
        
        <section id="sequencedandtupleparameters">
            <title>Sequenced and tuple parameters</title>
        
        <para>The elipsis <literal>...</literal> indicates that a parameter is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>sequenced parameter</emphasis>, which accepts a list of 
                arguments of the specified type <literal>T</literal>, or a single argument of 
                type <literal>Iterable&lt;T&gt;</literal>. Inside the method or class, the 
                sequenced parameter has type <literal>Iterable&lt;T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>tuple parameter</emphasis> representing a list of parameters 
                whose types are defined by a sequenced type parameter. Inside the method or class, 
                the argument has the pseudo-type of the sequenced type parameter and is assignable 
                to any tuple parameter of the same pseudo-type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>SequencedParam: Annotation* UnionType "..." MemberName</programlisting>
        
        <para>The sequenced parameter or tuple parameter must be the last parameter in the 
        list.</para>
        
        <programlisting>(Name name, Organization? org=null, Address... addresses)</programlisting>
        
        <programlisting>(Value instance, Argument... args)</programlisting>
        
        <comment><para>TODO: what is the syntax for sequenced parameters when declared by 
        reference?</para></comment>
        
        </section>
        
        <section id="entrydestructuring">
            <title>Destructuring for parameters of type <literal>Entry</literal></title>
        
        <para>A parameter of type <literal>Entry</literal> may be specified in 
        <emphasis>destructured</emphasis> form.</para>
        
        <programlisting>EntryParamPair: SimpleParam "->" SimpleParam</programlisting>
        
        <para>A destructured parameter declaration of form <literal>U u -> V v</literal> 
        results in a method with a single parameter of type <literal>Entry&lt;U,V&gt;</literal>,
        whose <literal>key</literal> and <literal>item</literal> attributes are assigned
        to <literal>u</literal> and <literal>v</literal> within the body of the method. If
        the method is invoked using a named argument list, it is considered to have two
        separate parameters <literal>u</literal> and <literal>v</literal>.</para>
        
        <programlisting>(Key key -> Item item)</programlisting>
        <programlisting>(String name -> String? password = "guest" -> null)</programlisting>
        
        </section>
        
    </section>
    
    <section id="annotations">
        <title>Program element annotations</title>

        <para>Declarations may be preceded by a list of annotations. An annotation is an
        initial lowercase identifier, optionally followed by an argument list. A list of 
        annotations does not require punctuation between the individual annotations in 
        the list.</para>
        
        <programlisting>Annotation: MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>For an annotation with no arguments, or with only literal-valued positional
        arguments, the parentheses around, and commas between, the positional arguments 
        may be omitted.</para>
        
        <programlisting>doc "The user login action"
by "Gavin King"
   "Andrew Haley"
throws (DatabaseException 
        -> "if database access fails")
seeAlso (LogoutAction.logout)
scope (session) 
action { description="Log In"; url="/login"; }
shared deprecated</programlisting>

        <para>An annotation is an invocation of a toplevel method that occurs when the 
        program element is loaded by the virtual machine. The return type of this toplevel 
        method is called the <emphasis>annotation type</emphasis> of the annotation. 
        Invocation of the toplevel method is called <emphasis>evaluation</emphasis> of the 
        annotation. The toplevel method may not declare type parameters.</para>
        
        <programlisting>shared Scope scope(Scope s) { return s; }</programlisting>
        <programlisting>shared Todo todo(String text) { return Todo(text); }</programlisting>

        <section id="annotationarguments">
            <title>Annotation arguments</title>
        
        <para>An annotation may be specified at a program element using any one of 
        three forms.</para>
        
        <itemizedlist>
        
        <listitem>
        <para>Using a positional argument invocation of the method:</para>
        
        <programlisting>doc("the name") String name;</programlisting>
        </listitem>
        
        <listitem>
        <para>Using a named argument invocation of the method:</para>
        
        <programlisting>doc {description="the name";} String name;</programlisting>
        </listitem>
        
        <listitem>
        <para>Or using the special abbreviated form for annotations with literal value
        arguments:</para>
        
        <programlisting>doc "the name" String name;</programlisting>
        </listitem>
        
        </itemizedlist>
                        
        </section>
        
        <section>
            <title>Annotation types</title>
            
            <para>The annotation type of an annotation must be a subtype of the interface 
            <literal>ConstrainedAnnotation</literal> defined in the package 
            <literal>ceylon.language.metamodel</literal>. Any type which is a subtype of 
            <literal>ConstrainedAnnotation</literal> is called an <emphasis>annotation 
            type</emphasis>.</para>
            
            <programlisting><![CDATA[shared interface ConstrainedAnnotation<out Value, out Values, in ProgramElement>
        of OptionalAnnotation<Value,ProgramElement> | SequencedAnnotation<Value,ProgramElement>
        satisfies Annotation<Value>
        given Value satisfies Annotation<Value>
        given ProgramElement satisfies Annotated {
    shared Boolean occurs(Annotated programElement) {
        return programElement is ProgramElement;
    }
}]]></programlisting>
        
            <para>The type arguments of this interface express constraints upon how 
            annotations which return the annotation type occur.</para> 
            
            <para>There are only two direct subtypes of <literal>ConstrainedAnnotation</literal>:</para>
            
            <programlisting><![CDATA[shared interface OptionalAnnotation<out Value, in ProgramElement>
        satisfies ConstrainedAnnotation<Value,Value?,ProgramElement>
        given Value satisfies Annotation<Value>
        given ProgramElement satisfies Annotated {}]]></programlisting>
               
            <programlisting><![CDATA[shared interface SequencedAnnotation<out T, in ProgramElement>
        satisfies ConstrainedAnnotation<Value,Value[],ProgramElement>
        given Value satisfies Annotation<Value>
        given ProgramElement satisfies Annotated {}]]></programlisting>
            
            <para>If <literal>A</literal> is an annotation type then:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If <literal>A</literal> is a subtype of <literal>OptionalAnnotation</literal>,
                    at most one annotation of annotation type <literal>A</literal> may occur 
                    at a given program element.</para>
                </listitem>
                <listitem>
                    <para>If <literal>A</literal> is a subtype of <literal>SequencedAnnotation</literal>,
                    multiple annotations of annotation type <literal>A</literal> may occur 
                    at a given program element.</para>
                </listitem>
                <listitem>
                    <para>If <literal>A</literal> is a subtype of <literal>OptionalAnnotation&lt;A,P&gt;</literal>,
                    or <literal>SequencedAnnotation&lt;A,P&gt;</literal> then an annotation 
                    of annotation type <literal>A</literal> may not occur at a program element
                    whose metamodel expression type is not assignable to <literal>P</literal>.</para>
                </listitem>
            </itemizedlist>
                        
            <programlisting><![CDATA[shared interface Scope
        of request | session | application
        satisfies OptionalAnnotation<Scope,Type<Object>> {}]]></programlisting>
            
            <programlisting><![CDATA[shared class Todo(String text)
        satisfies SequencedAnnotation<Todo,Annotated> {
    shared actual String string = text;
}]]></programlisting>
            
            <para>It is perfectly acceptable for multiple toplevel methods to return the same 
            annotation type.</para>
            
            <comment><para>TODO: should we let an annotation return multiple instances of an
            annotation type (<literal>A[]</literal> where <literal>A</literal> is an annotation
            type).</para></comment>
            
        </section>
        
        <section>
            <title>Annotation values</title>
            
            <para>An <emphasis>annotation value</emphasis> is the value returned when an
            annotation is evaluated. We may obtain the annotation values of all annotations
            of a given annotation type that occur at a given program element by passing the 
            annotation type and program element metamodel reference to the method
            <literal>annotations()</literal> defined in the package
            <literal>ceylon.language.metamodel</literal>.</para>
            
            <programlisting>Scope scope = annotations(Scope, Person) ? request;</programlisting>
            <programlisting>Todo[] todos = annotations(Todo, method);</programlisting>
            
        </section>
        
    </section>
    
    <!--
    <section id="metatype">
        <title>Metatypes</title>
        
        <para>For every type <literal>X</literal>, the <emphasis>metatype</emphasis> 
        <literal>MX</literal> of the type defines a typesafe metamodel of the members of 
        the type.</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>variable</literal> attribute of <literal>X</literal> 
                with type <literal>T</literal>, <literal>MX</literal> has an attribute with 
                the same name and type <literal>Attribute&lt;X,T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>variable</literal> attribute of <literal>X</literal> 
                with type <literal>T</literal>, <literal>MX</literal> has an attribute with 
                the same name and type <literal>MutableAttribute&lt;X,T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>X</literal> with return type <literal>R</literal> 
                and parameter types <literal>P...</literal>, <literal>MX</literal> has an 
                attribute with the same name and type <literal>Method&lt;X,R,P...&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>abstract</literal> member class <literal>Y</literal> 
                of <literal>X</literal>, <literal>MX</literal> has an attribute with the same 
                name and type <literal>MemberClass&lt;X,Y&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each non-<literal>abstract</literal> member class <literal>Y</literal> 
                of <literal>X</literal> with initializer parameter types <literal>P...</literal>, 
                <literal>MX</literal> has an attribute with the same name and type 
                <literal>MemberConcreteClass&lt;X,Y,P...&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    -->
        
</chapter>
