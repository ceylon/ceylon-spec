<chapter id="declarations">
    <title>Declarations</title>
    
    <para>Ceylon is a statically typed language. Classes, interfaces, methods, attributes 
    and locals must be declared before use. The declaration of a method, attribute, or
    local must include an explicit type, or allow the type to be infered. This allows the 
    compiler to detect many errors, including:</para>
    
    <itemizedlist>
        <listitem><para>typing errors in identifier names,</para></listitem>
        <listitem><para>references to types which do not exist or are not 
        visible,</para></listitem>
        <listitem><para>references to type members which do not exist or are not 
        visible,</para></listitem>
        <listitem><para>argument lists which do not match parameter lists,</para></listitem>
        <listitem><para>type argument lists which do not match type parameter 
        lists,</para></listitem>
        <listitem><para>incompatible assignment of an expression of one type to a
        program element of a different type,</para></listitem>
        <listitem><para>evaluation of an attribute or local before its value has been
        explicitly specified or assigned,</para></listitem>
        <listitem><para>assignment to a non-<literal>variable</literal> attribute or
        local,</para></listitem>
        <listitem><para>failure to refine a <literal>formal</literal> member of a 
        supertype,</para></listitem>
        <listitem><para>refinement of a non-<literal>formal</literal>, 
        non-<literal>default</literal> member of a supertype,</para></listitem>
        <listitem><para><literal>switch</literal> statements which do not exhaust all
        values of an enumerated type, and</para></listitem>
        <listitem><para><literal>switch</literal> statements which do not exhaust all 
        cases of a type with enumerated subtypes.</para></listitem>
    </itemizedlist>
    
    <para>All declarations follow a general pattern:</para>
        
    <programlisting>Annotation* 
(keyword | UnionType) (TypeName | MemberName) TypeParams? Params*
CaseTypes? Metatypes? AdaptedTypes? ExtendedType? SatisfiedTypes? AbstractedType?
TypeConstraints?
(Definition | ";")</programlisting>

    <para>A type parameter does not need an explicit declaration of this form unless it has 
    constraints. In the case that it does have constraints, the constraint declaration does 
    follow the general pattern.</para>
    
    <para>This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language.</para>

    <section id="compilationunitstructure">
        <title>Compilation unit structure</title>
        
        <para>A <emphasis>compilation unit</emphasis> is a text file, with the 
        filename extension <literal>.ceylon</literal>.</para>
        
        <para>A compilation unit consists of a list of imported types, attributes, and 
        methods, followed by one or more toplevel type, attribute, or method definitions.</para>
        
        <programlisting>Import* ToplevelDeclaration+</programlisting>
        
        <section id="topleveldeclarations">
            <title>Toplevel declarations</title>
        
        <para>A <emphasis>toplevel declaration</emphasis> defines a type&mdash;a class or 
        interface&mdash;or a method or non-<literal>variable</literal> attribute.</para>
        
        <programlisting>ToplevelDeclaration: TypeDeclaration | Method | SimpleAttribute | AttributeGetter</programlisting>
        
        <programlisting>TypeDeclaration: Class | Object | Interface</programlisting>
        
        <para>A toplevel declaration may not be annotated <literal>formal</literal>,
        <literal>default</literal>, <!--literal>definite</literal--> or
        <literal>actual</literal>.</para>
        
        <comment><para>TODO: In a future version of the language, we might relax this 
        restriction and support package extension with toplevel member refinement. This
        can be viewed as a regularization of the language. The practical application is
        that it would make toplevel invocations and instantiations polymorphic, obviating
        the need for things like dependency injection.</para></comment>
        
        </section>
        
        <section id="nesteddeclarations">
            <title>Nested declarations</title>
            
            <para>Most toplevel declarations contain nested declarations.</para>
            
            <programlisting>Declaration: Method | Attribute | TypeDeclaration</programlisting>
            
            <para>Nested declarations are often mixed together with executable statements.</para>
            
        </section>
        
    </section>
    
        <section id="imports">
            <title>Imports</title>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>.
        Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly <emphasis>imports</emphasis> the declaration using the 
        <literal>import</literal> statement.</para>
        
        <programlisting>Import: "import" FullPackageName "{" ImportElements? "}"</programlisting>
        
        <para>A package is a namespace. A full package name is a period-separated list of 
        all-lowercase identifiers.</para>
        
        <programlisting>FullPackageName: PackageName ("." PackageName)*</programlisting>
        
        <para>For a given package, there may be at most one <literal>import</literal>
        statement per compilation unit.</para>
        
        <para>Every package belongs to a <emphasis>module</emphasis>. An 
        <literal>import</literal> statement may import from a package if and only
        if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the package belongs to the same module as the compilation unit 
                containing the <literal>import</literal> statement, or</para>
            </listitem>
            <listitem>
                <para>the package is declared <literal>shared</literal> in its
                package descriptor, and the module descriptor of the module containing 
                the <literal>import</literal> statement explicitly imports the module 
                containing the package.</para>
            </listitem>
        </itemizedlist>
        
        <para>Each <literal>import</literal> statement imports one or more toplevel 
        declarations from the given package, specifying a list of <emphasis>import
        elements</emphasis>.</para>
        
        <programlisting>ImportElements: ImportElement ("," ImportElement)* ("," ImportWildcard)? | ImportWildcard</programlisting>
        
        <programlisting>ImportElement: ImportTypeElement | ImportMethodAttributeElement</programlisting>
        
        <para>An import element is a reference to either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a single toplevel type (a class or interface) of the package,</para>
            </listitem>
            <listitem>
                <para>a single toplevel method or attribute of the package, or</para>
            </listitem>
            <listitem>
                <para>all toplevel declarations of the package.</para>
            </listitem>
        </itemizedlist>
        
        <para>An import element may not refer to a non-<literal>shared</literal> 
        declaration.</para>
        
        <para>An <literal>import</literal> statement may not contain two import elements
        which refer to the same declaration.</para>
        
        <para>Note that toplevel declarations in the module <literal>ceylon.language</literal> 
        never need to be explicitly imported. They are implicitly imported by every 
        compilation unit.</para>
        
        <comment><para>Note: an unused import should result in a compiler warning.</para></comment>
                
        <section id="typeimports">
            <title>Type imports</title>
        
        <para>An import element that specifies a type name imports the toplevel type 
        with that name from the given package.</para>
        
        <programlisting>ImportTypeElement: TypeAlias? TypeName ("{" ImportElements? "}")?</programlisting>
        
        <para>A compilation unit may not import two types with the same name.</para>
        
        <programlisting>import java.util { Set, List, Map }</programlisting>
        
        <para>The import element may be followed by a list of nested import elements, 
        which must specify aliases.</para>
        
        <comment><para>Note: as a special exception to the usual language rules, to 
        support interoperation with Java, a nested import element which references a
        <literal>static</literal> member of a Java type results in a Ceylon
        <emphasis>toplevel</emphasis> reference to the <literal>static</literal> member. 
        In this case, the import element may omit the explicit alias.</para></comment>
        
        </section>
        
        <section id="methodattributeimports">
            <title>Method and attribute imports</title>
        
        <para>An import element that specifies a method or attribute name imports the 
        toplevel method or attribute with that name from the given package.</para>
        
        <programlisting>ImportMethodAttributeElement: MethodAttributeAlias? MemberName</programlisting>
        
        <para>A compilation unit may not import two methods or attributes with the same 
        name.</para>
        
        <programlisting>import ceylon.math { sqr, sqrt, e, pi }</programlisting>
        
        </section>
        
        <section id="aliasimports">
            <title>Alias imports</title>
               
        <para>The optional alias clause in a fully-explicit import allows resolution 
        of cross-namespace declaration name collisions.</para>
        
        <programlisting>TypeAlias: TypeName "="</programlisting>
        
        <programlisting>MethodAttributeAlias: MemberName "="</programlisting>
        
        <para>An alias assigns a different name to the imported declaration, or to a
        member of the imported declaration. This name is visible within the compilation
        unit in which the <literal>import</literal> statement occurs.</para>
        
        <programlisting>import java.util { JavaMap = Map }</programlisting>
        
        <programlisting>import my.math { fib = fibonnacciNumber }</programlisting>
        
        <programlisting>import java.lang { 
    Math { sin, cos, ln=log }, 
    System { sysprops=properties },
    Char=Character { upper=toUpperCase, lower=toLowerCase, char=charValue } 
}</programlisting>
        
        <comment><para>TODO: Currently, inheritance of two members with the same name
        from different unrelated types always results in a compile error. A similar 
        problem arises with introductions. We could let you resolve this class of problem 
        by aliasing a member of a type you're importing. This is a bit similar to what 
        Eiffel does, but it would be a lexical thing, scoped to the compilation unit. 
        For example:</para>
        <programlisting>import org.formats { Format { formatToString = format }, ... }</programlisting>
        </comment>
        
        </section>
        
        <section id="wildcardimports">
            <title>Wildcard imports</title>
        
        <para>The elipsis <literal>...</literal> acts as a wildcard in 
        <literal>import</literal> statements. An <literal>import</literal> statement 
        that specifies a wildcard imports all toplevel declarations of the package.</para>
        
        <programlisting>ImportWildcard: "..."</programlisting>
        
        <para>An <literal>import</literal> statement may specify a list of alias imports 
        followed by a wildcard. In this case, the alias imports are imported with the 
        specified names, and all other toplevel declarations are imported with their 
        declared names.</para>
        
        <programlisting>import ceylon.collection { ... }</programlisting>
        
        <programlisting>import my.math { fib = fibonnacciNumber, ... }</programlisting>
                
        <para>Overuse of wildcard imports is discouraged.</para>
        
        </section>
        
        <section>
            <title>Imported name</title>
            
            <para>Inside a compilation unit which imports a declaration, the declaration
            may be referred to by its <emphasis>imported name</emphasis>. For an import
            element with an alias, the imported name is the alias. For an import element
            with no alias, or for a wildcard import, the imported name is the name of the
            declaration.</para>
            
            <para>An import element may not result in an imported name that is the same
            as the name of a toplevel declaration contained in the compilation unit in
            which the import element occurs.</para>
            
            <para>Two import elements occurring in the same compilation unit may not result 
            in the same imported name.</para>
            
        </section>
        
        </section>
        
        <!--
        <section id="introductions">
            <title>Introductions</title>
            
            <para>An <emphasis>introduction</emphasis> results in an additional assignability
            relationship within a certain compilation unit. The <literal>adapt</literal>
            statement <emphasis>introduces</emphasis> one or more interfaces, called the
            <emphasis>introduced types</emphasis> to another type, called the
            <emphasis>adapted type</emphasis>:</para>
            
            <programlisting>Introduction: "adapt" Type SatisfiedTypes TypeConstraints? ";"</programlisting>
            
            <para>A single compilation unit may not have multiple <literal>adapt</literal>
            statements for the same adapted type.</para>
            
            <para>Every introduced type listed in the <literal>satisfies</literal> clause
            must satisfy the following:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the introduced type must not be a supertype of the adapted
                    type,</para>
                </listitem>
                <listitem>
                    <para>the adapted type must be a subtype of every class satisfied
                    by the introduced type,</para>
                </listitem>
                <listitem>
                    <para>for every <literal>formal</literal> member of the introduced 
                    type, there must be a member of the adapted type such that the two
                    members refine, directly or indirectly, a common member of a common
                    supertype, and</para>
                </listitem>
                <listitem>
                    <para>every <literal>actual</literal> member of the introduced type 
                    must also be declared <literal>default</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: should we add the following requirements:</para>
            <itemizedlist>
                <listitem>
                    <para>the introduced type must not refine, directly or indirectly, 
                    a member of the adapted type,</para>
                </listitem>
                <listitem>
                    <para>if the introduced type and the adapted type both refine, 
                    directly or indirectly, a common member of a common supertype, the 
                    adapted type must directly or indirectly refine the member of the 
                    introduced type.</para>
                </listitem>
            </itemizedlist>
            </comment>
            
            <para>The list of introduced types must satisfy the following:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if two introduced types both have a member that refines, 
                    directly or indirectly, a common member of a common supertype, then 
                    either the adapted type must also have a member that refines the 
                    common member, directly or indirectly, or one of the introduced type 
                    members must be declared <literal>formal</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Within the compilation unit that contains an introduction, the adapted
            type is assignable to the introduced type.</para>
            
            <para>At runtime, an operation upon the adapted type (method invocation, member 
            class instantiation, or attribute evaluation) is dispatched according to the 
            following rule:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If the runtime type of the instance of the adapted type declares 
                    or refines the operation, the operation is dispatched to the runtime
                    type of the instance.
                    </para>
                </listitem>
                <listitem>
                    <para>Otherwise, the operation is dispatched to the unique introduced 
                    type that has a concrete definition of the operation.
                    </para>
                </listitem>
            </itemizedlist>
            
            <programlisting>adapt Sequence&lt;T&gt; 
        satisfies SequenceList&lt;T&gt;
        given T satisfies Equality;</programlisting>
            
        </section>
        -->
    
    <section id="parameters">
        <title>Parameters</title>
    
        <para>A method or class declaration may declare a list or <emphasis>parameters</emphasis>, 
        including, optionally:</para>
        
        <itemizedlist>
            <listitem>
                <para>one or more <emphasis>defaulted parameters</emphasis> (parameters with 
                default values), and/or</para>
            </listitem>
            <listitem>
                <para>a <emphasis>sequenced parameter</emphasis> (a "vararg" parameter).</para>
            </listitem>
        </itemizedlist>
        
        <para>In a parameter list, parameters with default values must occur after required 
        parameters. The sequenced parameter, if any, must occur last.</para>
        
        <programlisting>Params: 
"("
Param ("," Param)* ("," DefaultParam)* ("," SequencedParam)? | 
DefaultParam ("," DefaultParam)* ("," SequencedParam)? | 
SequencedParam?
")"</programlisting>

        <para>Each parameter is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>declared with an explicit type and name and may have annotations and/or 
                parameters of its own, or</para>
            </listitem>
            <listitem>
                <para>a named reference to a simple attribute or local.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Param: Annotation* (SimpleParam | CallableParam | EntryParamPair) | MemberName</programlisting>
        
        <programlisting>SimpleParam: UnionType MemberName</programlisting>
        
        <!--para>A parameter may not be be declared <literal>variable</literal>, and may not be 
        assigned to within the body of the method or class.</para-->
                
        <para>In the case of a reference, the name of the parameter must be the name of a 
        simple attribute or local of the method or class it parameterizes, and the type of the 
        parameter is the type of this simple attribute or local. Any argument to the parameter 
        is used as the initial value of the attribute or local to which it refers.</para>
        
        <programlisting>class Person(name, age=0) {
    shared String name;
    shared variable Integer age;
}</programlisting>
        
        <section id="callableparameters">
            <title>Callable parameters</title>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>callable parameter</emphasis>.</para>
        
        <programlisting>CallableParam: (UnionType | "void") MemberName Params+</programlisting>
        
        <para>Think of this as an abstract local method that must be defined by the caller 
        when the method is invoked or the class is instantiated.</para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(Value x, Value y))</programlisting>
        
        <para>A callable parameter declaration is equivalent to a parameter declaration with 
        no parameter lists where the type is the callable type of the method declaration. So 
        the above are equivalent to:</para>
        
        <programlisting>(String label, Callable&lt;Object&gt; onClick)</programlisting>
        
        <programlisting>(Callable&lt;Comparison,Value,Value&gt; by)</programlisting>
        
        </section>
        
        <section id="defaultedparameters">
            <title>Defaulted parameters</title>
        
        <para>Defaulted parameters specify a default argument.</para>
    
        <programlisting>DefaultParam: Param Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate 
        a value which cannot be reassigned.</para>
        
        <programlisting>Specifier: "=" (Expression | Function)</programlisting>
        
        <para>Defaulted parameters must occur after non-defaulted parameters in the parameter 
        list.</para>
        
        <programlisting>(Product product, Integer quantity=1)</programlisting>
        
        <para>The type of the default argument expression must be assignable to the declared
        type of the parameter.</para>
        
        <!--
        <para>If the declared type of the parameter is an optional type (a subtype of
        <literal>Nothing</literal>) then the default argument expression must be a value
        reference to <literal>null</literal>.</para>
        -->
        
        <para>A parameter of a method or class annotated <literal>actual</literal> may not 
        specify a default argument.</para>
        
        <para>A parameter of a method or class annotated <literal>actual</literal> inherits 
        the default argument, if any, if the corresponding parameter of the method it 
        refines.</para>
        
        <para></para>
        
        </section>
        
        <section id="sequencedandtupleparameters">
            <title>Sequenced and tuple parameters</title>
        
        <para>The elipsis <literal>...</literal> indicates that a parameter is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>sequenced parameter</emphasis>, which accepts a list of 
                arguments of the specified type <literal>T</literal>, or a single argument of 
                type <literal>T[]</literal>. Inside the method or class, the sequenced parameter 
                has type <literal>T[]</literal>.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>tuple parameter</emphasis> representing a list of parameters 
                whose types are defined by a sequenced type parameter. Inside the method or class, 
                the argument has the pseudo-type of the sequenced type parameter and is assignable 
                to any tuple parameter of the same pseudo-type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>SequencedParam: Annotation* UnionType "..." MemberName</programlisting>
        
        <para>The sequenced parameter or tuple parameter must be the last parameter in the 
        list.</para>
        
        <programlisting>(Name name, Organization? org=null, Address... addresses)</programlisting>
        
        <programlisting>(Value instance, Argument... args)</programlisting>
        
        <comment><para>TODO: what is the syntax for sequenced parameters when declared by 
        reference?</para></comment>
        
        </section>
        
        <section id="entrydestructuring">
            <title>Destructuring for parameters of type <literal>Entry</literal></title>
        
        <para>A parameter of type <literal>Entry</literal> may be specified in 
        <emphasis>destructured</emphasis> form.</para>
        
        <programlisting>EntryParamPair: SimpleParam "->" SimpleParam</programlisting>
        
        <para>A destructured parameter declaration of form <literal>U u -> V v</literal> 
        results in a method with a single parameter of type <literal>Entry&lt;U,V&gt;</literal>,
        whose <literal>key</literal> and <literal>item</literal> attributes are assigned
        to <literal>u</literal> and <literal>v</literal> within the body of the method. If
        the method is invoked using a named argument list, it is considered to have two
        separate parameters <literal>u</literal> and <literal>v</literal>.</para>
        
        <programlisting>(Key key -> Item item)</programlisting>
        <programlisting>(String name -> String? password = "guest" -> null)</programlisting>
        
        </section>
        
    </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type schema, together with 
        implementation details for some members of the type. Interfaces may not be 
        directly instantiated.</para>
        
        <programlisting>Interface: Annotation* InterfaceHeader (InterfaceBody | TypeSpecifier ";")</programlisting>
        
        <para>An interface declaration may optionally specify a list of type 
        parameters. An interface declaration may have a list of extended interfaces,
        a list of metatypes, an enumerated list of subtypes, and/or a list of type 
        constraints.</para>
        
        <programlisting>InterfaceHeader: "interface" TypeName TypeParams? InterfaceInheritance TypeConstraints?</programlisting>
        
        <programlisting>InterfaceInheritance: CaseTypes? Metatypes? AdaptedTypes? SatisfiedTypes?</programlisting>
        
        <para>To obtain a concrete instance of an interface, it is necessary to define 
        and instantiate a class that satisfies the interface, or define an anonymous 
        class that satisfies the interface.</para>
        
        <!--<section id="interfacebodies">
            <title>Interface bodies</title>-->
            
        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface and <literal>abstract</literal> class declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>InterfaceBody: "{" Declaration* "}"</programlisting>
        
        <para>Unlike the body of a class, method, or attribute, the body of an interface
        is not executable, and does not directly contain procedural code.</para>

        <programlisting>shared interface Comparable&lt;Other&gt; {
    
    shared formal Comparison compare(Other other);
    
    shared Boolean largerThan(Other other) {
        return compare(other)==larger;
    }
    
    shared Boolean smallerThan(Other other) {
        return compare(other)==smaller;
    }
    
}</programlisting>

        <para>An interface may declare <literal>formal</literal> methods, attributes,
        and member classes, and concrete methods, attribute getters, attribute setters, 
        and member classes. An interface may not declare a concrete simple attribute or 
        member <literal>object</literal>.</para>
        
        <!--para>A member of an interface may not be annotated <literal>definite</literal>.</para-->
        
        <para>A non-<literal>abstract </literal> nested class declaration is called a
        <emphasis>member class</emphasis> of the interface. A nested interface or 
        <literal>abstract</literal> class declaration is not part of the schema of the 
        interface type, and is therefore not considered a member of the interface.</para>
        
        <section id="interfacebodies">
            <title>Interface bodies</title>
            
        <para>The body of an interface consists purely of declarations. The following 
        constructs may not occur sequentially in the body of an interface:</para>
        
        <itemizedlist>
            <listitem>
                <para>a statement or control structure,</para>
            </listitem>
            <listitem>
                <para>a method or attribute declaration with a specifier or initializer, 
                or</para>
            </listitem>
            <listitem>
                <para>an <literal>object</literal> declaration.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <!--section id="interfacemembervisibility">
            <title>Interface member visibility</title>
            
        <para>An interface body is not an executable block of code, so the normal
        visibility rules that apply to declarations inside blocks do not apply.
        Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that 
        occur within the lexical scope of the declaration. This rule is relaxed for 
        declarations that occur directly inside the body of an interface:</para>
        
        <itemizedlist>
            <listitem>
                <para>any declaration annotated <literal>shared</literal> is 
                visible wherever the interface itself is visible, and</para>
            </listitem>
            <listitem>
                <para>any declaration not declared using the <literal>value</literal> 
                or <literal>function</literal> keywords is visible to all other 
                declarations in the the body of the interface.</para>
            </listitem>
        </itemizedlist>
        
        </section-->
        
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may satisfy any number of other interfaces.<!--and may satisfy
            a single class--></para>
        
            <programlisting>shared interface List&lt;Element&gt;
        satisfies Sequence&lt;Element&gt; &amp; Collection&lt;Element&gt; 
        given Element satisfies Object {
    ...
}</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are 
            supertypes of the interface type. Every extended type must be an interface. 
            An interface may not satisfy the same interface twice (not even with distinct 
            type arguments).</para>
            
            <!--At most one supertype of the interface may be a class. The remaining 
            supertypes of an interface must be interfaces.-->
            
            <para>An interface may adapt any number of interfaces, and at most one class.</para>
            
            <programlisting>shared interface SequenceList&lt;Element&gt;
        adapts Sequence&lt;Element&gt;
        satisfies List&lt;Element&gt; 
        given Element satisfies Object {
    ...
}</programlisting>
            
            <para>The types listed after the <literal>adapts</literal> keyword are also
            supertypes of the interface type. Every adapted type must be an interface or
            class. At most one adapted type may be a class. An interface may not adapt 
            the same type twice (not even with distinct type arguments).</para>
            
            <!--
            <para>If an interface does not explicitly declare the class it satisfies using
            <literal>satisfies</literal>, it satisfies the class 
            <literal>ceylon.language.Object</literal>.</para>
            -->
             
            <para>An interface inherits all members (methods, attributes and member types) 
            of every supertype.<!--except for members refined by the interface or by some 
            supertype of the interface.--></para>
            
            <!--
            <para>An interface inherits every class satisfied by every other interface the 
            interface satisfies. There must exist a unique satisfied class that is a subclass
            of all classes satisfied by the interface.</para>
            -->
            
            <para>The schema of the inherited members is formed by substituting type 
            arguments specified in the <literal>satisfies</literal> or <literal>adapts</literal> 
            clause.</para>
            
            <para>If an interface satisfies an introduction, the interface must itself be
            an introduction, and the adapted type of the interface must be a subtype of 
            the adapted type of the introduction it satisfies.</para>
            
            <!--
            <para>An interface may not inherit two non-<literal>formal</literal> members
            of different supertypes that both refine the same member of a third supertype.
            If two supertypes both declare non-<literal>formal</literal> members that
            refine the same member of a third supertype, the interface must also refine
            the member.</para>
            -->
            
             <para>An interface that satisfies a nested interface must be a member of the type 
             that declares the nested interface or of a subtype of the type that declares the 
             nested interface.</para>
             
        </section>
        
    <section id="interfaceswithcases">
        <title>Interfaces with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of an interface declaration specifies the 
        list of cases of the interface.</para>
        
        <programlisting>shared interface Node&lt;Element&gt; 
        of Root&lt;Element&gt; | Branch&lt;Element&gt; | Leaf&lt;Element&gt; { ... }</programlisting>
        
        <para>The cases may be interfaces, classes, or toplevel anonymous classes. A case 
        may be an <literal>abstract</literal> class. Each case must be a subtype of the
        interface type.</para>
                
        <para>If an interface has an <literal>of</literal> clause, then every subtype of 
        the interface must be subtype of one of the enumerated cases.</para>
                
    </section>
    
    <section id="interfacealiases">
        <title>Interface aliases</title>
        
        <para>An interface declaration which specifies a reference to another interface
        type defines an <emphasis>interface alias</emphasis> of the specified interface 
        type.</para>
        
        <programlisting>TypeSpecifier: "=" Type</programlisting>

        <para>The specified interface type may be a produced type (it may specify type 
        arguments). An interface alias simply assigns an alternative name to the original 
        interface type or produced type.</para>
        
        <programlisting>shared interface PeopleByName = Map&lt;String,Person&gt;;</programlisting>
        
        <programlisting>interface Compare&lt;Value&gt; = Callable&lt;Comparison,Value,Value&gt;;</programlisting>
                
        <para>Interface aliases are not reified types. The metamodel reference for an 
        interface alias&mdash;for example, <literal>PeopleByName</literal>&mdash;returns 
        the metamodel object for the aliased interface&mdash;in this case, 
        <literal>Map&lt;String,Person&gt;</literal>.</para>
    
    </section>
        
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.</para>

        <programlisting>Class: Annotation* ClassHeader (ClassBody | TypeSpecifier ";")</programlisting>
        
        <para>An ordinary class declaration specifies a list of parameters required to 
        instantiate the type, and, optionally a list of type parameters.  A class 
        declaration may have a superclass, a list of extended interfaces, a list of 
        metatypes, an enumerated list of subtypes, and/or a list of type constraints.</para>
        
        <programlisting>ClassHeader: "class" TypeName TypeParams? Params ClassInheritance TypeConstraints?</programlisting>
        
        <programlisting>ClassInheritance: CaseTypes? Metatypes? ExtendedType? SatisfiedTypes?</programlisting>
        
        <para>To obtain an instance of a class, it is necessary to instantiate the
        class, or a subclass of the class.</para> 
        
    <!--<section id="classbodies">
        <title>Class bodies</title>-->
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations,</para>
            </listitem>
            <listitem>
                <para>nested interface and <literal>abstract</literal> class declarations, 
                and</para>
            </listitem>
            <listitem>
                <para>instance initialization code.</para>
            </listitem>
        </itemizedlist>

        <programlisting>ClassBody: "{" (Declaration | Statement)* "}"</programlisting>
        
        <para>The body of a class may contain executable code.</para>
        
        <programlisting>shared class Counter(Integer initialCount=0) {
    
    log.info("Initial count: " initialCount "");
    
    variable Integer n = initialCount;
    
    shared void increment() {
        n++;
        log.info("Count: " n "");
    }
    
    shared Integer count {
        return n;
    }
    
}</programlisting>
        
        <para>A non-<literal>abstract </literal> nested class declaration is called a
        <emphasis>member class</emphasis> of the class. A nested interface or 
        <literal>abstract</literal> class declaration is not part of the schema of the 
        class type, and is therefore not considered a member of the class.</para>
        
        <!--
        <para>The body of a class may invoke, evaluate or assign members of the instance 
        being initialized&mdash;the current instance of the class&mdash;without explicitly 
        specifying the receiver.</para>
        
        <para>The body of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class or interface&mdash;the receiving instance 
        of the instantiation expression&mdash;without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method, or attribute, in which 
        case the body of the class may refer to any non-<literal>variable</literal> local, 
        block local attribute getter or block local method declared earlier within the 
        containing scope. It may not refer to <literal>variable</literal> locals from the 
        containing scope.</para>
        -->

    <section id="initializerparameters">
        <title>Initializer parameters</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead, the body of the class declares <emphasis>initializer parameters</emphasis>. 
        An initializer parameter may be used anywhere in the class body, including in 
        method and attribute definitions.</para>
        
        <para>An initializer parameter may be used to specify or initialize the value 
        of an attribute:</para>
        
        <programlisting>shared class Counter(Integer initialCount=0) {
    shared variable Integer count := initialCount;
    shared void increment() { count++; }
}</programlisting>
        
        <para>Or, using a more streamlined syntax:</para>
                
        <programlisting>shared class Counter(count=0) {
    shared variable Integer count;
    shared void increment() { count++; }
}</programlisting>
        
        <para>An initializer parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>shared class Key(Lock lock) {
    shared void lock() { lock.engage(this); }
    shared void unlock() { lock.disengage(this); }
}</programlisting>

    </section>

    <section id="callabletypeofclass">
        <title>Callable type of a class</title>
        
        <para>The <emphasis>callable type</emphasis> of a class captures the type and parameter 
        types of the class. The callable type is <literal>Callable&lt;T,P...&gt;</literal>, where
        <literal>T</literal> is the class and <literal>P...</literal> are the parameter types 
        of the class. A sequenced parameter is considered of type <literal>T[]</literal>
        where <literal>T...</literal> is the declared sequenced type.</para>
        
        <para>An <literal>abstract</literal> class is not callable.</para>
    
    </section>
    
    <section id="initializersection">
        <title>Initializer section</title>
    
        <para>The initial part of the body of a class is called the 
        <emphasis>initializer</emphasis> of the class and contains a mix of declarations, 
        statements and control structures. The initializer is executed every time the 
        class is instantiated.</para>
           
        <para>A class initializer is responsible for initializing the state of the new 
        instance of the class, before a reference to the new instance is available to 
        clients.</para>
        
        <programlisting>shared abstract class Point() {
    shared formal Decimal x;
    shared formal Decimal y;
}</programlisting>
        
        <programlisting>shared class DiagonalPoint(Decimal distance) 
        extends Point() {
    
    Decimal pos = distance / 2**0.5;
    x = pos;
    y = pos;
    
    assert ("must have distance " distance " from origin") 
        that ( x**2 + y**2 &equals; distance**2 );
    
}</programlisting>
        
        <programlisting>shared object origin 
        extends Point() {
    x = 0.0;
    y = 0.0;
}</programlisting>
        
        <para>Within a class initializer, a <emphasis>self reference to the instance 
        being initialized</emphasis> is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>the expression <literal>this</literal>, unless contained in a
                nested class declaration, or</para>
            </listitem>
            <listitem>
                <para>the expression <literal>outer</literal>, contained in a directly
                nested class declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A statement or declaration contained in the initializer of a class may 
        not evaluate an attribute, invoke a method, or instantiate a member class upon 
        the instance being initialized, including upon a self reference to the instance 
        being initialized if the attribute, method, or member class:</para>
        
        <itemizedlist>
           <listitem>
              <para>occurs later in the body of the class,</para>
           </listitem>
           <listitem>
              <para>is annotated <literal>formal</literal> or <literal>default</literal>,
              or</para>
           </listitem>
           <listitem>
              <para>is inherited from an interface or superclass, and is not refined 
              by a declaration occurring earlier in the body of the class.</para>
           </listitem>
        </itemizedlist>
        
        <para>A member class contained in the initializer of a class may not 
        <literal>extend</literal> a member or nested class of an interface or 
        superclass of the class.</para>
        
        <para>Furthermore, a statement or declaration contained in the initializer 
        of a class may not:</para>
        
        <itemizedlist>
           <listitem>
              <para>pass a self reference to the instance being initialized as an 
              argument of an instantiation, method invocation, or <literal>extends</literal> 
              clause expression or as the value of an attribute assignment or 
              specification, or</para>
           </listitem>
           <listitem>
              <para><literal>return</literal> a self reference to the instance being 
              initialized.</para>
           </listitem>
        </itemizedlist>
        
        <para>Nor may the a class pass a self reference to the instance being initialized
        as an argument of its own <literal>extends</literal> clause expression, if any.</para>
        
        <para>Finally, the initializer of a class may not attempt to narrow the type of a
        self reference to the instance being initialized using the <literal>if (is ...)</literal>
        construct.</para>
        
        <para>The initializer of a class is executed after the initializer of its 
        superclass.</para>
                
        <para>For example, the following code fragments are not legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
    class Node() {
        nodes.add(this);    //compiler error (this reference in initializer)
    }
}</programlisting>
        
        <programlisting>class Graph() {
    class Node() {}
    Node createNode() {
        Node node = Node();
        nodes.add(node);    //compiler error (forward reference in initializer)
        return node;
    }
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
}</programlisting>

        <para>But this code fragment is legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
    Node createNode() {
        Node node = Node();
        nodes.add(node);
        return node;
    }
    class Node() {}
}</programlisting>

    </section>
    
    <section id="declarationsection">
        <title>Declaration section</title>
        
        <para>The remainder of the body of the class consists purely of declarations, 
        similar to the body of an interface. The following constructs may not occur 
        sequentially in the declaration section:</para>
        
        <itemizedlist>
            <listitem>
                <para>a statement or control structure,</para>
            </listitem>
            <listitem>
                <para>a method or attribute declaration with a specifier or 
                initializer,</para>
            </listitem>
            <listitem>
                <para>an <literal>object</literal> declaration with a non-empty 
                initializer section, or</para>
            </listitem>
            <listitem>
                <para>an <literal>object</literal> declaration that directly extends 
                a class other than <literal>Object</literal> or 
                <literal>IdentifiableObject</literal> in the module 
                <literal>ceylon.language</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>However, the declarations in this second section may freely use 
        <literal>this</literal> and <literal>super</literal>, and may invoke any method,
        evaluate any attribute, or instantiate any member class of the class or its 
        superclasses. <!--Furthermore, the usual restriction that a declaration may only be 
        used within the lexical scope of the declaration is relaxed unless it is a 
        <literal>value</literal> or <literal>function</literal> declaration with an 
        inferred type.--></para>
        
    </section>
           
    <!--section id="classmembervisibility">
        <title>Class member visibility</title>
        
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        within the lexical scope of the declaration. This rule is relaxed for certain 
        declarations that occur directly inside the body of a class:</para>
        
        <itemizedlist>
            <listitem>
                <para>any declaration annotated <literal>shared</literal> is visible 
                wherever the class itself is visible, and</para>
            </listitem>
            <listitem>
                <para>any declaration that occurs in the declaration section of the body 
                of the class and is not declared using the <literal>value</literal> 
                or <literal>function</literal> keywords is visible to all other 
                declarations in the declaration section.</para>
            </listitem>
        </itemizedlist>
        
    </section-->

        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>A class may extend another class.</para>
        
        <programlisting>shared class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>

        <para>The class specified after the <literal>extends</literal> keyword is the
        superclass of the class.</para>

        <para>
        If a class does not explicitly specify a superclass using <literal>extends</literal>,
        its superclass is the class <literal>IdentifiableObject</literal> defined in 
        <literal>ceylon.language</literal>.
        </para>
        
        <para>A class may satisfy any number of interfaces.</para>

        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt; &amp; Identifier {
    ... 
}</programlisting>
        
        <para>The interfaces listed after the <literal>satisfies</literal> keyword are 
        supertypes of the class. A class may not satisfy the same interface twice (not 
        even with distinct type arguments).</para>
        
        <para>A class:</para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of every 
                supertype, <!--except for members refined by the class or by some supertype 
                of the class,--></para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that refines each 
                <literal>formal</literal> member of every interface it satisfies directly 
                or indirectly, unless the class is declared <literal>abstract</literal> or
                <literal>formal</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that refines each 
                <literal>formal</literal> member of its superclass, unless the class is 
                declared <literal>abstract</literal> or <literal>formal</literal>.</para>
            </listitem>
            <!--
            <listitem>
                <para>must directly or indirectly extend every class satisfied by every 
                interface it satisfies directly or indirectly.</para>
            </listitem>
            -->
            <!--listitem>
                <para>is assignable to any type to which any interface it satisfies is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>The schema of the inherited members is formed by substituting type arguments
        specified in the <literal>extends</literal> or <literal>satisfies</literal> clause.</para>
        
        <!--
        <para>A class may not inherit two non-<literal>formal</literal> members of 
        different supertypes that both refine the same member of a third supertype.
        If two supertypes both declare non-<literal>formal</literal> members that
        refine the same member of a third supertype, the class must also refine
        the member.</para>
        -->
            
        <para>If a class satisfies an introduction, the class must be a subtype of the 
        adapted type of the introduction.</para>
            
        <para>The initializer of the superclass of a class is always executed before the 
        initializer of the class whenever the class or any one of its subclasses is 
        instantiated.</para>
        
        <para>A subclass must pass values to each superclass initialization parameter in 
        the <literal>extends</literal> clause.</para>

        <programlisting>shared class SpecialKey1()
        extends Key( SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>shared class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>
         
         <para>A subclass of a nested class must be a member of the type that declares 
         the nested class or of a subtype of the type that declares the nested class. 
         A class that satisfies a nested interface must be a member of the type that 
         declares the nested interface or of a subtype of the type that declares the 
         nested interface.</para>
         
        </section>
        
        <section>
            <title>Restrictions on user-defined classes</title>
            
            <para>The following classes may not be directly extended by any class defined
            outside the module <literal>ceylon.language</literal> or appear as an upper
            bound of any type parameter:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Callable</literal>,
                    <emphasis>TODO: remove this restriction</emphasis></para>
                </listitem>
                <listitem>
                    <para><literal>Boolean</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>Integer</literal> and  <literal>Float</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>Character</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>String</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>Entry</literal>, and</para>
                </listitem>
                <listitem>
                    <para><literal>Range</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>This allows the compiler to perform certain optimizations upon these 
            types.</para>
            
        </section>
       
        <!--
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or multiple 
            nested classes of the same containing body may declare the same name. The 
            classes are called <emphasis>overloaded</emphasis>.</para>
            
            <para>For any class name and package or containing body, there must be a 
            single <emphasis>root class</emphasis> with the given name belonging to 
            the given package or body. Other classes with the same name belonging to the 
            same package or body:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend the root class,</para>
                </listitem>
                <listitem>
                    <para>must have distinct erased signatures,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root class, may not declare any member with a 
                    visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root class, except in 
            instantiation expressions. An instantiation expression is resolved to a 
            particular overloaded class declaration at compile time, using the argument 
            expression types.</para>
        
            <para>A package or body may not declare or inherit two classes with the 
            same name unless either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the classes are overloaded,</para>
                </listitem>
                <listitem>
                    <para>one class refines the other class, or</para>
                </listitem>
                <listitem>
                    <para>one class is defined by a supertype, and is not visible
                    to the subtype that defines the other class.</para>
                </listitem>
            </itemizedlist>
        
        </section>
        -->
        
    <section id="abstractandformalclasses">
        <title>Abstract, formal, and default classes</title>
        
        <para>A toplevel or nested class may be annotated <literal>abstract</literal>
        and is called an <literal>abstract</literal> class.</para>
                
        <para>If a class annotated <literal>shared</literal> is a member of a containing 
        class or interface, then the class may be annotated <literal>formal</literal>
        and is called a <literal>formal</literal> member class, or, sometimes, an 
        <emphasis>abstract member class</emphasis>.</para>
        
        <para>An <literal>abstract</literal> class or <literal>formal</literal> member
        class may have <literal>formal</literal> members.</para>
        
        <para>An <literal>abstract</literal> class may not be instantiated.</para>
        
        <para>A <literal>formal</literal> member class may be instantiated.</para>
        
        <para>A class which is not annotated <literal>formal</literal> or <literal>abstract</literal>
        is called a <emphasis>concrete</emphasis> class.</para>
                
        <para>A concrete class may not have <literal>formal</literal> members.</para>
        
        <para>If a concrete class annotated <literal>shared</literal> is a member of a 
        containing class or interface, then the class may be annotated 
        <literal>default</literal> and is called a <literal>default</literal> member
        class.</para>
        
        <para>A toplevel class may not be annotated <literal>formal</literal> or 
        <literal>default</literal>.</para>
        
        <para>A block local class may not be annotated <literal>formal</literal> or 
        <literal>default</literal>.</para>

        <comment><para>Note: a <literal>formal</literal> member class would be a
        reasonably syntax for declaring virtual types. We think we don't need 
        virtual types because they don't offer much that type parameters don't
        already provide. For example:</para>
        <programlisting>shared formal class Buffer(Character...) 
        satisfies Sequence&lt;Character&gt;;</programlisting></comment>
        
        <!--
        <para>A member of an <literal>abstract</literal> or <literal>formal</literal> class 
        may not be annotated <literal>definite</literal>.</para>
        -->
                
    </section>
            
    <section id="refiningmemberclasses">
        <title>Member class refinement</title>
        
        <para>Member class refinement is a unique feature of Ceylon, akin to the
        "factory method" pattern of many other languages.</para>
        
        <itemizedlist>
            <listitem>
                <para>A member class annotated <literal>formal</literal> or
                <literal>default</literal> may be refined by any class or 
                interface which is a subtype of the class or interface which 
                declares the member class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>formal</literal> 
                <emphasis>must</emphasis> be refined by every concrete class 
                which is a subtype of the class or interface that declares the 
                member class, unless the class inherits a concrete member class 
                from a superclass that refines the <literal>formal</literal> 
                member class.</para>
            </listitem>
        </itemizedlist>
        
        <para>A member class of a subtype <emphasis>refines</emphasis> a member 
        class of a supertype if the first member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>is annotated <literal>actual</literal>,</para>
            </listitem>
            <listitem>
                <para>has the same name as the member class it refines, and</para>
            </listitem>
            <listitem>
                <para>has a parameter list with the same signature as the member 
                class it refines, after substitution of type arguments specified 
                in the <literal>extends</literal> or <literal>satisfies</literal>
                clause, and either</para>
            </listitem>
            <listitem>
                <para>directly or indirectly extends the member class it refines.</para>
            </listitem>
            <!--
            <listitem>
               <para>extends the superclass of the member class it refines and 
               satisfies all interfaces satisfied by the member class it 
               refines, where the member class it refines is a 
               <literal>formal</literal> member class with no body.</para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>Finally, the refined member class must be visible to the member
        class annotated <literal>actual</literal>.</para>
        
        <para>If a member class is annotated <literal>actual</literal>, it must 
        refine some class defined by a supertype, and the class it refines 
        must be either <literal>formal</literal> or <literal>default</literal>.</para>
            
        <para>A member class may not, directly or indirectly, refine two different
        member classes not themselves annotated <literal>actual</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
                
        <programlisting>shared abstract class Reader() {
    shared formal class Buffer(Character... chars) 
            satisfies Sequence&lt;Character&gt; {}
    ...
}</programlisting>

        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) 
            extends Reader.Buffer(chars) {
        ...
    }
    ...
}</programlisting>
        
        <!--
        <para>But in the special case where the member class it refines does not
        specify a body, the refining class is not required to extend the member 
        class it refines:</para>
        
        <programlisting>shared abstract class Reader() {
    shared formal class Buffer(Character... chars) 
            satisfies Sequence&lt;Character&gt;;
    ...
}</programlisting>

        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) 
            satisfies Sequence&lt;Character&gt; {
        ...
    }
    ...
}</programlisting>
        
        <para>A member class alias may refine a member class.</para>
        
        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) = String;
    ...
}</programlisting>
        -->
         
    </section>
    
    <section id="anonymousclasses">
        <title>Anonymous classes</title>
        
        <para>An <literal>object</literal> declaration makes it possible to define
        a class, instantiate the class, and declare an attribute referring to the 
        resulting class instance in a single declaration.</para>
        
        <programlisting>Object: Annotation* ObjectHeader ClassBody</programlisting>
        
        <para>An <literal>object</literal> has an initial lowercase identifier.
        An <literal>object</literal> declaration does not specify parameters or
        type parameters.</para>
        
         <programlisting>ObjectHeader: "object" MemberName ObjectInheritance</programlisting>
         
         <programlisting>ObjectInheritance: ExtendedType? SatisfiedTypes?</programlisting>
         
         <para>An <literal>object</literal> declaration specifies the name of the
         attribute and the schema, supertypes, and implementation of the class. It
         does not specify a type name. Instead, the type has a name assigned 
         internally by the compiler that is not available at compilation time.</para>
         
         <para>An <literal>object</literal> class:</para>
         
         <itemizedlist>
             <!-- 
             <listitem>
                 <para>is implicitly <literal>final</literal>,</para>
             </listitem>
             -->
             <listitem>
                 <para>may not be extended by another class,</para>
             </listitem>
             <listitem>
                 <para>may not be <literal>abstract</literal> or <literal>formal</literal>, 
                 and</para>
             </listitem>
             <listitem>
                 <para>may not declare <literal>default</literal> members.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> is annotated <literal>shared</literal>, 
         the class is <literal>shared</literal>.<!-- If the <literal>object</literal> 
         is annotated <literal>variable</literal>, the class is a <literal>variable</literal> 
         class.--></para>
         
         <para>This class never appears in types inferred by local declaration type 
         inference or generic type argument inference. Instead, occurrences of the class 
         are replaced with the intersection of the extended type with all satisfied
         types.</para>
         
         <para>An <literal>object</literal> attribute:</para>
         
         <itemizedlist>
             <listitem>
                 <para>is non-<literal>variable</literal>, and</para>
             </listitem>
             <listitem>
                 <para>may not be refined or declared <literal>default</literal>.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> is annotated <literal>shared</literal>, 
         the attribute is <literal>shared</literal>. If the <literal>object</literal>
         is annotated <literal>actual</literal>, it refines an attribute of a 
         supertype.</para>
         
         <para>The following declaration:</para>
         
         <programlisting>shared object red extends Color('FF0000') {
     shared actual String string = "Red";
}</programlisting>

         <para>Is exactly equivalent to:</para>
         
         <programlisting>class Color_red extends Color('FF0000') {
     shared actual String string = "Red";
}

shared Color_red red = Color_red();</programlisting>
         
         <para>Where <literal>Color_red</literal> is a name generated by the compiler.
         The algorithm for generating this name is not specified here.</para>
         
         <para>Note that a member of an anonymous class that is not annotated 
         <literal>actual</literal> may only be accessed from within the body of 
         the anonymous class or by directly invoking the <literal>object</literal> 
         attribute.</para>
         
         <programlisting>shared object sql {
    shared String escape(String string) { ... }
}

...

String escapedSearchString = sql.escape(searchString);</programlisting>

        <comment><para>TODO: I'm increasingly inclined to think that this is backwards:
        a class should be an <literal>object</literal> with parameters. We could rewrite
        this stuff so that a <literal>class</literal> is equivalent to an interface with
        a typeclass that satisfies <literal>Callable</literal> and returns a nested 
        <literal>object</literal>. We might have to make an <literal>object</literal> a 
        type, and give it an uppercase name, and/or let you <literal>extend</literal> an
        <literal>object</literal> but that would end up a little more regular anyway, 
        since the <literal>of</literal> clause would now always contain a list of types. 
        The only oddity would be that some common values would getter uppercase names: 
        <literal>True</literal>, <literal>False</literal>, <literal>Null</literal>, 
        etc.</para></comment>
        
        <comment><para>TODO: Alternatively, a different approach to making this feature
        feel more regular, that is also perhaps more practically useful, would be to 
        reconceptualize the syntax above as a kind of attribute declaration, and also
        support a parameterized <literal>object</literal> declaration&mdash;which would
        be a useful shortcut for specifying a callable parameter value in a named argument 
        list or refining a method declaration when the callable parameter or method has an 
        abstract return type.</para></comment>
        
        <comment><para>TODO: Should we support <literal>object</literal>s as part of the
        expression syntax, like anonymous classes in Java. The syntax would be, for 
        example:</para>
        <programlisting>return object extends AbstractReader(stream) { 
        ...
    };</programlisting>
        <programlisting>return object satisfies Usable { 
        actual void begin() { ... } 
        actual void close() { ... } 
    };</programlisting>
        <para>This is can be viewed as regular, following the same pattern as a regular 
        class instantiation, which can be written either as <literal>x = X { ... };</literal> 
        or as <literal>X x { ... }</literal>. Here we're letting you write either 
        <literal>x = object satisfies X { ... };</literal> or 
        <literal>object x satisfies X { ... }</literal>.</para>
        </comment>
        
        <!--
        <comment><para>TODO: We could add a built-in type constructor to give access to 
        the concrete type of an <literal>object</literal>. It would look something like
        <literal>type&lt;sql&gt;</literal> and in theory you could let it accept any
        expression, even stuff like <literal>type&lt;foo.x+bar.y&gt;</literal>.</para></comment>
        -->
        
    </section>
    
    <section id="classeswithcases">
        <title>Classes with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of a class declaration specifies the 
        list of cases of the class.</para>
        
        <programlisting>shared abstract class Boolean() 
        of true | false 
        extends Case() {}
        
shared object true extends Boolean() {}
shared object false extends Boolean() {}</programlisting>

        <programlisting><![CDATA[shared abstract class Node<Element>(String name) 
        of Branch<Element> | Leaf<Element> { ... }
        
shared class Leaf<Element>(String name, Element element) 
        extends Node<Element>(name) { ... }
        
shared class Branch<Element>(String name, Node<Element> left, Node<Element> right) 
        extends Node<Element>(name) { ... }]]></programlisting>
                
        <para>The cases may be classes or toplevel anonymous classes. A case may 
        be an <literal>abstract</literal> class. Each case must be a subclass of 
        the class.</para>
                        
        <para>If a class has an <literal>of</literal> clause, then every subtype 
        of the class must be a subtype of one of the enumerated cases.</para>
        
        <para>A non-<literal>abstract</literal> class may not have an <literal>of</literal> 
        clause.<!--A <literal>final</literal> class may not have an <literal>of</literal> 
        clause. --></para>
        
        <!--
        <comment><para>TODO: We could let a non-<literal>abstract</literal> class
        limit its subtypes. In which case we could use the syntax <literal>of none</literal> 
        to mean <literal>final</literal>.</para></comment>
        -->
        
        <comment><para>TODO: Should we introduce an abbreviated syntax like:</para>
        <programlisting>shared abstract class Boolean() of case true | case false {}</programlisting>
        <para>Note that it must be <literal>case</literal> instead of <literal>object</literal>
        to resolve an ambiguity between an annotation and the class body followed by 
        a declaration.</para>
        </comment>
        
    </section>
        
    <section id="classaliases">
        <title>Class aliases</title>
        
        <para>A class declaration which specifies a reference to another class type 
        defines a <emphasis>class alias</emphasis> of the specified class type.</para>
        
        <para>The specified class type may be a produced type (it may specify type 
        arguments). A class alias simply assigns an alternative name to the original 
        class type or produced type.</para>
        
        <programlisting>shared class People(Person... people) = ArrayList&lt;Person&gt;;</programlisting>
        
        <para>The callable type of the specified type must be assignable to the 
        callable type of the class alias.</para>
        
        <para>Class aliases are not reified types. The metamodel reference for a class 
        alias&mdash;for example, <literal>People</literal>&mdash;returns the metamodel 
        object for the aliased class&mdash;in this case, 
        <literal>ArrayList&lt;Person&gt;</literal>.</para>
    
    </section>
        
    </section>
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may 
        have parameters and may return a value.</para>
        
        <programlisting>Method: Annotation* MethodHeader (Block | Specifier? ";")</programlisting>
        
        <para>All method declarations specify the method name, one or more parameter 
        lists, and, optionally, a list of type parameters. A method declaration may 
        specify a type, called the <emphasis>return type</emphasis>, to which the 
        values the method returns are assignable, or it may specify that the method 
        is a <literal>void</literal> method&mdash;a method which does not return a 
        value. The return type of a <literal>void</literal> method is considered to 
        be <literal>Void</literal>. A method declaration may have a list of type 
        constraints.</para>
        
        <programlisting>MethodHeader: (UnionType | "function" | "void") MemberName TypeParams? Params+ Metatypes? TypeConstraints?</programlisting>
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <!--<section id="methodbodies">
            <title>Method bodies</title>-->
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a method is referenced by a parameter, it must not specify any 
        implementation.</para>

        <!--
        <para>A member method body may invoke, evaluate or assign members of the instance
        being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member method body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class or interface (the containing instance 
        of the instance upon which the method was invoked) without explicitly specifying the 
        receiver.</para>
        
        <para>A toplevel method body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>variable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>variable</literal> locals from the containing scope.</para>
        -->
        
        <section id="callabletype">
            <title>Callable type of a method</title>
            
        <para>The <emphasis>callable type</emphasis> of a method captures the return
        type and parameter types of the method.</para>
        
        <itemizedlist>
        <listitem>
            <para>The callable type of a method with a single parameter list is 
            <literal>Callable&lt;R,P...&gt;</literal> where <literal>R</literal> is the 
            return type of the method, or <literal>Void</literal> if the method is 
            <literal>void</literal>, and <literal>P...</literal> are the parameter types 
            of the method.</para>
        </listitem>
        <listitem>
            <para>The callable type of a method with multiple parameter lists is 
            <literal>Callable&lt;O,P...&gt;</literal>, where <literal>O</literal> is the
            callable type of a method produced by eliminating the first parameter list, 
            and <literal>P...</literal> are the parameter types of the first parameter 
            list of the method.</para>
        </listitem>
        </itemizedlist>
        
        <para>A sequenced parameter is considered of type <literal>T[]</literal> where 
        <literal>T...</literal> is the declared sequenced type.</para>
        
        </section>
        
        <section id="methodswithblocks">
            <title>Methods with blocks</title>
            
        <para>A method implementation may be a block. If the method is a <literal>void</literal> 
        method, the block may not contain a <literal>return</literal> directive that 
        specifies an expression. Otherwise, every conditional execution path of the block 
        must end in a <literal>return</literal> directive that specifies an expression
        assignable to the return type of the method.</para>
        
        <programlisting>shared Integer add(Integer x, Integer y) {
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token();
}</programlisting>

        <programlisting>shared void print(Object... objects) {
    for (Object obj in objects) {
        log.info($obj);
    }
}</programlisting>

        <programlisting>shared void addEntry(Key key -> Item item) {
    map.define(key,item);
}</programlisting>

        <programlisting><![CDATA[shared Set<Element> singleton<Element>(Element element) 
        given Element satisfies Comparable<Element> {
    return TreeSet(element);
}]]></programlisting>
        
        <!--
        <programlisting>shared Float[n] float&lt;#n&gt;(Decimal[n] decimals) {
    return Vector&lt;Float,#n&gt;() 
                containing (Bounded&lt;#n&gt; i) (decimals[i].float);
}</programlisting>
        -->
        
        <para>Note that a method which declares the return type <literal>Void</literal>
        is not a <literal>void</literal> method. A method with declared type 
        <literal>Void</literal> must return a value of type <literal>Void</literal> 
        (any value will do).</para>
        
        <programlisting>void say(String) { ... }

void hello() {
    say("hello");
}
        
Void goodbye() {
    return say("goodbye");
}</programlisting>
        
        <para>A non-<literal>void</literal> block local method may be declared using 
        the keyword <literal>function</literal> in place of the explicit return type 
        declaration. Then the method return type is inferred:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the method contains no <literal>return</literal> directive,
                then the return type of the method is <literal>Bottom</literal> (this
                is the case where the method always terminates in a <literal>throw</literal>
                directive), or</para>
            </listitem>
            <listitem>
                <para>otherwise, the return type of the method is the union of all 
                returned expression types of <literal>return</literal> directives
                of the method body.</para>
            </listitem>
        </itemizedlist>
        
        <para>This method has inferred return type <literal>Integer</literal>.</para>

        <programlisting>function add(Integer x, Integer y) {
    return x + y;
}</programlisting>

        <para>This method has inferred return type <literal>Float|Integer</literal>.</para>

        <programlisting>function unit(Boolean floating=false) {
    if (floating) {
        return 1.0;
    }
    else {
        return 1;
    }
}</programlisting>

        <para>This method has inferred return type <literal>Bottom</literal>.</para>

        <programlisting>function die() {
    throw;
}</programlisting>

        
        </section>
        
        <section id="methodswithspecifiers">
            <title>Methods with specifiers</title>
            
        <para>Alternatively, a method implementation may be an expression that evaluates 
        to a callable object, specified using <literal>=</literal>. The type of the 
        callable object must be assignable to the callable type of the method.</para>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Float sqrt(Float x) = 2.root;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>The callable object expression may not refer to parameters of the
        method.</para>
        
        <para>A block local method which specifies a callable object expression may be 
        declared using the keyword <literal>function</literal> in place of the explicit 
        return type declaration. The return type of the method is inferred to be the
        type of the type argument to the first type parameter of the expression type
        <literal>Callable</literal> (the return type).</para>
        
        <programlisting>function sqrt(Float x) = 2.root;</programlisting>
        
        </section>
        
        <section id="methodforwarddeclaration">
            <title>Forward declaration of methods</title>
            
            <para>The declaration of a method may be separated from the specification
            of the callable object. If a method declaration does have a specifier, named 
            arguments, or a block, and is not annotated <literal>formal</literal>, it is 
            a <emphasis>forward-declared</emphasis> method.</para>
            
        <programlisting>Comparison order(Value x, Value y);
if (reverseOrder) {
    function reverse(Value x, Value y) { return y&lt;=&gt;x; }
    order = reverse;
}
else {
    function natural(Value x, Value y) { return x&lt;=&gt;y; }
    order = natural;
}</programlisting>
            
            <para>Every forward-declared method must explicitly specify a type. It may 
            not be declared using the keyword <literal>function</literal>.</para>
        
            <para>A toplevel method may not be forward-declared. A method of an interface
            may not be forward-declared.</para>
            
        </section>
                
        <section id="multipleparameterlists">
            <title>Methods with multiple parameter lists</title>
            
        <para>A method may declare multiple lists of parameters. A method which 
        declares more than one parameter list returns instances of 
        <literal>Callable</literal>. The compiler infers a nested method whose
        callable type is formed by taking the method with multiple parameter 
        lists and eliminating the first parameter list.</para>
        
        <!--
        <para>The type of the expression specified by the <literal>return</literal> 
        directive may be be assignable to either:</para>
        
        <itemizedlist>
            <listitem><para>the callable type of a method produced by taking the 
            method with multiple parameter lists and eliminating the first parameter 
            list, or</para></listitem>
            <listitem><para>the declared return type of the method.</para></listitem>
        </itemizedlist>
        
        <para>If the <literal>return</literal> expression type is assignable to the 
        callable type of the method produced by eliminating the first parameter 
        list of the method, the method body may <emphasis>only</emphasis> refer to 
        parameters in the first parameter list. It may not refer to parameters of 
        other parameter lists. Parameters declared by parameter lists other than the 
        first parameter list are not considered visible inside the body of the 
        method.</para>
        
        <programlisting>Comparison getOrder()(Integer x, Integer y) {
    Comparison order(Integer x, Integer y) { return x&lt;=&gt;y; }
    return order;
}</programlisting>

        <para>Otherwise, if the <literal>return</literal> expression type is assignable 
        to the declared return type of the method, the method body may refer to any
        parameter in any one of the parameter lists of the method. The compiler 
        automatically infers a series of nested methods, one for each parameter list of 
        the method. The declarations and statements in the method body form the body of 
        the most nested inferred method.</para>
        -->
        
        <para>This method declaration:</para>
        
        <programlisting>Comparison getOrder()(Integer x, Integer y) {
    return x&lt;=&gt;y;
}</programlisting>

        <para>is equivalent to the following:</para>

        <programlisting>Callable&lt;Comparison,Integer,Integer&gt; getOrder() {
    Comparison order(Integer x, Integer y) { return x&lt;=&gt;y; }
    return order;
}</programlisting>

        <para>For a method with <literal>n</literal> parameter lists, there are 
        <literal>n</literal> inferred methods. The <literal>i</literal>th inferred 
        method:</para>
        
        <itemizedlist>
            <listitem>
                <para>has the same return type as the original declared method,</para>
            </listitem>
            <listitem>
                <para>has the same parameter lists as the declared method, after 
                eliminating the first <literal>i-1</literal> parameter lists, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>i&lt;n</literal>, has a body which contains the
                definition of the <literal>i+1</literal>th inferred method and 
                simply returns a reference to that method, or</para>
            </listitem>
            <listitem>
                <para>otherwise, if <literal>i=n</literal>, has the body of the original
                declared method.</para>
            </listitem>
        </itemizedlist>
        
        <para>The first inferred method replaces the original declared method in the 
        definition of the class.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>function fullName(String firstName)(String middleName)(String lastName) {
    return firstName + " " + middleName + " " + lastName;
}</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>function fullName(String firstName) {
    function fullName2(String middleName) {
        function fullName3(String lastName) {
            return firstName + " " + middleName + " " + lastName;
        }
        return fullName3;
    }
    return fullName2;
}</programlisting>
                        
        </section>
        
        <!--
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>Multiple toplevel methods belonging to the same package, or multiple 
            methods of the same containing body may may declare the same name. A class or
            interface may declare or inherit multiple methods with the same name. The 
            methods are called <emphasis>overloaded</emphasis>. Overloaded methods:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must have distinct erased signatures, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>A class may not not declare or inherit a method with the same name as
            an attribute it declares or inherits.</para>
            
            <para>An invocation expression is resolved to a particular overloaded method 
            declaration at compile time, using the argument expression types.</para>
            
            <para>A package or body may not declare or inherit two methods with the 
            same name unless either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the methods are overloaded,</para>
                </listitem>
                <listitem>
                    <para>one method refines the other method, or</para>
                </listitem>
                <listitem>
                    <para>one method is defined by a supertype, and is not visible
                    to the subtype that defines the other method.</para>
                </listitem>
            </itemizedlist>
        
        </section>
        -->
        
       <section id="formalmethods">
            <title>Formal and default methods</title>
            
            <para>If a method declaration does have a specifier, named arguments, or a 
            block, and is annotated <literal>shared</literal>, and is a member of 
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>an interface, or</para>
                </listitem>
                <listitem>
                    <para>a class annotated <literal>abstract</literal> or 
                    <literal>formal</literal>,</para>
                </listitem>
            </itemizedlist> 
            
            <para>then the method declaration may be annotated <literal>formal</literal>, 
            and is called a <literal>formal</literal> method, or, sometimes, an 
            <emphasis>abstract method</emphasis>.</para>
            
            <programlisting>shared formal Item? get(Key key);</programlisting>

            <para>A method which is not annotated <literal>formal</literal> is called 
            a <emphasis>concrete</emphasis> method.</para>
        
            <para>If a concrete method is annotated <literal>shared</literal>, and is 
            a member of a class or interface, then it may be annotated <literal>default</literal>
            and is called a <literal>default</literal> method.
            <!--or <literal>definite</literal> <emphasis>(Note that <literal>definite</literal> is a 
            proposed feature for a future version of the language.)</emphasis> --></para>
            
            <programlisting>shared default void writeLine(String line) {
    write(line);
    write("\n");
}</programlisting>

            <para>A method annotated <literal>formal</literal> may not specify an
            implementation (a specifier, named arguments, or a block).</para>
        
            <para>A method annotated <literal>default</literal> may specify an
            implementation (a specifier, initializer, named arguments, or a block), or
            may be forward-declared.</para>
        
            <para>Every <literal>formal</literal> method must explicitly specify a type. 
            It may not be declared using the keyword <literal>function</literal>.</para>
        
            <para>A toplevel method may not be annotated <literal>formal</literal> or
            <literal>default</literal>.</para>

            <para>A block local method may not be annotated <literal>formal</literal> or
            <literal>default</literal>.</para>
                  
        </section>
                
        <section id="refiningmethods">
            <title>Method refinement</title>
            
            <para>Methods may be refined, just like in other object-oriented languages.</para>
            
            <itemizedlist>
            <listitem>
                <para>A class or interface may refine any <literal>formal</literal> 
                or <literal>default</literal> method it inherits, unless it inherits 
                a non-<literal>formal</literal> non-<literal>default</literal> method that 
                refines the method.</para>
            </listitem>
            <listitem>
                <para>A concrete class must refine every <literal>formal</literal> 
                <!--or <literal>definite</literal>--> method it inherits, unless it inherits 
                a non-<literal>formal</literal> <!--non-<literal>definite</literal>--> 
                method that refines the method.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A method of a subtype <emphasis>refines</emphasis> a method of
            a supertype if the first method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>actual</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the method it refines,</para>
                </listitem>
                <listitem>
                    <para>has the same number of parameter lists, with the same
                    signatures, as the method it refines, after substitution of 
                    type arguments specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause of the class, and</para>
                </listitem>
                 <listitem>
                    <para>has a return type that is assignable to the return type 
                    of the method it refines in the compilation unit containing
                    the method annotated <literal>actual</literal>, after 
                    substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the refined method must be visible to the method
            annotated <literal>actual</literal>.</para>
            
            <para>If a method is annotated <literal>actual</literal>, it must 
            refine some method defined by a supertype, and the method it refines 
            must be either <literal>formal</literal> or <literal>default</literal>. 
            <!--or <literal>definite</literal>.--></para>
            
            <para>A method may not, directly or indirectly, refine two different
            methods not themselves annotated <literal>actual</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <programlisting>shared abstract class AbstractSquareRooter() {
    shared formal Float squareRoot(Float x);
}</programlisting>

            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    shared actual Float squareRoot(Float x) { ... }
}</programlisting>
            
            <para>For <literal>formal</literal> methods, a special shortcut form of 
            refinement is permitted. A subclass initializer may simply specify an 
            instance of <literal>Callable</literal> as the implementation of the method 
            declared by the supertype. No parameter list, return type declaration, or 
            <literal>actual</literal> annotation is necessary.</para>
            
            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    Float sqrt(Float x) { ... }
    squareRoot = sqrt;
}</programlisting>
            
            <para>Toplevel methods cannot be refined, and so toplevel method invocation 
            is never polymorphic.</para>
            
            <!--
            <comment><para>TODO: are you allowed to refine the default value of a 
            defaulted parameter?</para></comment>
            
            <comment><para>TODO: are you required to have the same parameter names in 
            the two methods? I don't see that this would be necessary. In a named 
            argument invocation, you just use the names declared by the member of the 
            compile-time type, and they are mapped positionally to the parameters of 
            the refining method.</para></comment>
            -->
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Attribute: Annotation* (SimpleAttribute | AttributeGetter | AttributeSetter)</programlisting>
    
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be refined by subclasses.</para>
        
        <para>All attributes have a type and name. The type of the attribute is specified
        by the simple attribute declaration or attribute getter declaration. An attribute 
        may be <literal>variable</literal>, in which case its value can be assigned using 
        the <literal>:=</literal> and compound assignment operators. This is the case for
        simple attributes explicitly annotated <literal>variable</literal>, or for 
        attributes with a setter declaration.</para>
            
        <programlisting>AttributeHeader: (UnionType | "value") MemberName</programlisting>
        
        <para>Note that an attribute declaration is essentially a method declaration with 
        zero parameter lists. Likewise, an attribute evaluation is essentially a method 
        invocation with zero argument lists.</para>
        
        <para>A toplevel attribute may not be <literal>variable</literal>.</para>
        
        <para>If a class declares or inherits a <literal>variable</literal> attribute, it 
        must (directly or indirectly) extend the class <literal>IdentifiableObject</literal> 
        defined in <literal>ceylon.language</literal>.</para>
        
        <!--
        <para>An attribute of type <literal>Gettable</literal> or <literal>Settable</literal> 
        may not be <literal>variable</literal>.</para>
        -->
        
        <!--<section id="attributebodies">
            <title>Attribute bodies</title>-->
        <!-- 
        <para>A member attribute body may invoke, evaluate or assign members of the 
        instance being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member attribute body of a member class may invoke, evaluate or assign 
        members of the current instance of the containing class or interface (the containing 
        instance of the instance upon which the attribute was invoked) without explicitly 
        specifying the receiver.</para>
        
        <para>A toplevel attribute body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, 
        in which case it may refer to any non-<literal>variable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>variable</literal> locals from the containing scope.</para>
        -->
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state. The value of a simple attribute or local
        may be specified or initialized as part of the declaration, via a later 
        specification statement or assignment, or via a parameter that references it.</para>
        
        <programlisting>SimpleAttribute: AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <para>A simple attribute or local annotated <literal>variable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>variable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>variable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>variable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer: ":=" Expression</programlisting>
        
        <para>If a simple attribute or local is referenced by a parameter, it must not have
        an initializer or specifier.</para>

        <para>Explicitly typed parameters of classes and methods are also considered to be 
        locals.</para>
                 
        <programlisting>variable Integer count := 0;</programlisting>
        
        <programlisting>shared Integer max = +99;</programlisting>

        <programlisting>shared Decimal pi = calculatePi();</programlisting>
        
        <programlisting>shared Integer[] evenDigits = {0,2,4,6,8};</programlisting>

        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, 
                attribute getter, attribute setter, or control structure) is a local.</para>
            </listitem>
             <listitem>
                <para>A simple attribute declared inside the body of a class is a local if it 
                is not used inside a method, attribute setter or attribute getter 
                declaration and if it is not annotated <literal>shared</literal>.</para>
            </listitem>
           <listitem>
                <para>A parameter of a class is a local if it is not used inside a method, 
                attribute setter, or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur within the lexical scope of the declaration (later in the same 
        block or class body).</para>
        
        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        <para>A block local simple attribute with a specifier or initializer may be declared 
        using the keyword <literal>value</literal> in place of the explicit type declaration. 
        The type of the local or attribute is inferred to be the type of the specifier or
        initializer expression.</para>
        
        <programlisting>value names = List&lt;String&gt;();</programlisting>
        <programlisting>variable value count:=0;</programlisting>
                
        </section>
        
        <section id="attributeforwarddeclaration">
            <title>Forward declaration of simple attributes</title>
            
            <para>The declaration of a simple attribute or local may be separated from the 
            specification or initialization of its value. If an attribute declaration does
            have a specifier, initializer, named arguments, or a block, and if it is not
            annotated <literal>formal</literal>, it is a <emphasis>forward-declared</emphasis> 
            simple attribute or local.</para>
            
            <programlisting>String greeting;
switch (language)
case (en) {
    greeting = "Hello";
}
case (es) {
    greeting = "Hola";
}
else {
    throw LanguageNotSupported();
}
print(greeting);</programlisting>
            
            <para>Every forward-declared simple attribute must explicitly specify a type.
            It may not be declared using the keyword <literal>value</literal>.</para>
        
            <para>A toplevel attribute may not be forward-declared. An attribute of an 
            interface may not be forward-declared.</para>
            
        </section>
        
        <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is a callable block of code with no parameters,
            that returns a value.</para>
            
            <programlisting>AttributeGetter: AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
                                
            <programlisting>shared Float total {
    variable Float sum := 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum;
}</programlisting>
        
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>variable</literal>. Otherwise we say it is 
            non-<literal>variable</literal>.</para>
                        
            <para>A block local attribute getter may be declared using the keyword 
            <literal>value</literal> in place of the explicit type declaration. Then 
            the attribute type is inferred:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the getter contains no <literal>return</literal> directive,
                then the type of the attribute is <literal>Bottom</literal> (this is 
                the case where the getter always terminates in a <literal>throw</literal>
                directive), or</para>
            </listitem>
            <listitem>
                <para>otherwise, the type of the attribute is the union of all returned 
                expression types of <literal>return</literal> directives of the getter 
                body.</para>
            </listitem>
        </itemizedlist>
        
            <para>This attribute has inferred type <literal>Name</literal>.</para>
        
            <programlisting>value name { 
    return Name(firstName, initial, lastName);
}</programlisting>
                
        </section>
                
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is a callable block of code that accepts a single 
            value and does not return a value.</para>
            
            <programlisting>AttributeSetter: "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name. The getter declaration must directly occur earlier in the body
            containing the setter declaration.</para>


            <programlisting>shared String name { return join(firstName, lastName); }
shared assign name { firstName := first(name); lastName := last(name); }</programlisting>
                        
            <para>A setter may not be annotated <literal>shared</literal>, 
            <literal>default</literal> or <literal>actual</literal>. The visibility 
            and refinement modifiers of an attribute with a setter are specified by 
            annotating the matching getter.</para>
            
            <comment><para>TODO: should we require that the corresponding getter be 
            annotated <literal>variable</literal>?</para></comment>
            
            <!--
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para>
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            </comment>
            -->
            
        </section>
        
        <section id="formalattributes">
            <title>Formal and default attributes</title>
            
            <para>If an attribute declaration does have a specifier, initializer, named 
            arguments, or a block, and is annotated <literal>shared</literal>, and is a 
            member of either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>an interface, or</para>
                </listitem>
                <listitem>
                    <para>a class annotated <literal>abstract</literal> or 
                    <literal>formal</literal>,</para>
                </listitem>
            </itemizedlist> 
            
            <para>then the attribute declaration may be annotated <literal>formal</literal>, 
            and is called a <literal>formal</literal> attribute, or, sometimes, an 
            <emphasis>abstract attribute</emphasis>.</para>
            
            <programlisting>shared formal variable String firstName;</programlisting>

            <para>An attribute which is not annotated <literal>formal</literal> is called 
            a <emphasis>concrete</emphasis> attribute.</para>
        
            <para>If a concrete attribute is annotated <literal>shared</literal>, and is 
            a member of a class or interface, then it may be annotated <literal>default</literal>
            and is called a <literal>default</literal> attribute.
            <!--or <literal>definite</literal> <emphasis>(Note that <literal>definite</literal> is a 
            proposed feature for a future version of the language.)</emphasis> --></para>
            
            <programlisting>shared default String greeting = "Hello";</programlisting>

            <para>An attribute annotated <literal>formal</literal> may not specify an
            implementation (a specifier, initializer, named arguments, or a block). Nor
            may there be a setter for a formal attribute.</para>
        
            <para>An attribute annotated <literal>default</literal> may specify an
            implementation (a specifier, initializer, named arguments, or a block), or
            may be forward-declared.</para>
        
            <para>Every <literal>formal</literal> attribute must explicitly specify a type. 
            It may not be declared using the keyword <literal>function</literal>.</para>
        
            <para>A toplevel attribute may not be annotated <literal>formal</literal> or
            <literal>default</literal>.</para>

            <para>A block local attribute may not be annotated <literal>formal</literal> or
            <literal>default</literal>.</para>

        </section>
                
        <section id="refiningattributes">
            <title>Attribute refinement</title>
            
            <para>Ceylon allows attributes to be refined, just like methods. This helps
            eliminate the need for Java-style getter and setter methods.</para>
            
            <itemizedlist>
            <listitem>
                <para>A class or interface may refine any <literal>formal</literal> 
                or <literal>default</literal> attribute it inherits, unless it inherits 
                a non-<literal>formal</literal> non-<literal>default</literal> 
                attribute that refines the attribute.</para>
            </listitem>
            <listitem>
                <para>A concrete class must refine every <literal>formal</literal> 
                <!--or <literal>definite</literal>--> attribute it inherits, unless it 
                inherits a non-<literal>formal</literal> <!--non-<literal>definite</literal>-->
                attribute that refines the attribute.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A non-<literal>variable</literal> attribute may be refined by a simple 
            attribute or attribute getter. A <literal>variable</literal> attribute may be 
            refined by a <literal>variable</literal> simple attribute or by an attribute 
            getter and setter pair.</para>
            
            <comment><para>TODO: are you allowed to refine a getter or setter without also 
            refining its matching setter or getter?</para></comment>
            
            <para>An attribute of a subtype <emphasis>refines</emphasis> an attribute of
            a supertype if the first attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>actual</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the attribute it refines,</para>
                </listitem>
                 <listitem>
                    <para>has a type that is assignable to the type of the attribute it 
                    refines in the compilation unit containing the attribute annotated 
                    <literal>actual</literal>, after substitution of type arguments 
                    specified in the <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class,</para>
                </listitem>
                 <listitem>
                    <para>or has <emphasis>exactly the same type</emphasis> as the 
                    attribute it refines, after substitution of type arguments specified 
                    in the <literal>extends</literal> or <literal>satisfies</literal> clause
                    of the class, if the attribute it refines is <literal>variable</literal>, 
                    and</para>
                </listitem>
                <listitem>
                    <para>is <literal>variable</literal>, if the attribute it refines is 
                    <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the refined attribute must be visible to the attribute 
            annotated <literal>actual</literal>.</para>
        
            <para>If an attribute is annotated <literal>actual</literal>, it must 
            refine some attribute defined by a supertype, and the attribute it 
            refines must be either <literal>formal</literal> or <literal>default</literal>. 
            <!--or <literal>definite</literal>.--></para>
            
            <para>An attribute may not, directly or indirectly, refine two different
            attributes not themselves annotated <literal>actual</literal>.</para>
        
            <para>A non-<literal>variable</literal> attribute may be refined by a 
            <literal>variable</literal> attribute.</para>
            
            <comment><para>TODO: Is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you refine an interface
            attribute, but not when you refine a superclass attribute?</para></comment>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <programlisting>shared abstract class AbstractPi() {
    shared formal Float pi;
}</programlisting>

            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    shared actual Float pi { ... }
}</programlisting>
            
            <para>For <literal>formal</literal>, non-<literal>variable</literal> 
            attributes, a special shortcut form of refinement is permitted. A 
            subclass initializer may simply specify a value to the attribute 
            declared by the superclass. No type declaration or <literal>actual</literal> 
            annotation is necessary.</para>
            
            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float calculatePi() { ... }
    pi = calculatePi();
}</programlisting>

            <comment><para>TODO: Should we allow this for <literal>variable</literal>
            attributes?</para></comment>
            
            <comment><para>TODO: Why not also allow this for <literal>default</literal>
            attributes and methods?</para></comment>
            
            <para>Toplevel attributes cannot be refined, and so toplevel attribute 
            evaluation and assignment is never polymorphic.</para>
            
        </section>
                        
    </section>
        
    <section id="annotations">
        <title>Program element annotations</title>

        <para>Declarations may be preceded by a list of annotations. An annotation is an
        initial lowercase identifier, optionally followed by an argument list. A list of 
        annotations does not require punctuation between the individual annotations in 
        the list.</para>
        
        <programlisting>Annotation: MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>For an annotation with no arguments, or with only literal-valued positional
        arguments, the parentheses around, and commas between, the positional arguments 
        may be omitted.</para>
        
        <programlisting>doc "The user login action"
by "Gavin King"
   "Andrew Haley"
throws (DatabaseException,
        "if database access fails")
seeAlso (LogoutAction.logout)
scope (session) 
action { description="Log In"; url="/login"; }
shared deprecated</programlisting>

        <para>An annotation is an invocation of a toplevel method that occurs when the 
        program element is loaded by the virtual machine. The return type of this toplevel 
        method is called the <emphasis>annotation type</emphasis> of the annotation. 
        Invocation of the toplevel method is called <emphasis>evaluation</emphasis> of the 
        annotation. The toplevel method may not declare type parameters.</para>
        
        <programlisting>shared Scope scope(Scope s) { return s; }</programlisting>
        <programlisting>shared Todo todo(String text) { return Todo(text); }</programlisting>

        <section id="annotationarguments">
            <title>Annotation arguments</title>
        
        <para>An annotation may be specified at a program element using any one of 
        three forms.</para>
        
        <itemizedlist>
        
        <listitem>
        <para>Using a positional argument invocation of the method:</para>
        
        <programlisting>doc("the name") String name;</programlisting>
        </listitem>
        
        <listitem>
        <para>Using a named argument invocation of the method:</para>
        
        <programlisting>doc {description="the name";} String name;</programlisting>
        </listitem>
        
        <listitem>
        <para>Or using the special abbreviated form for annotations with literal value
        arguments:</para>
        
        <programlisting>doc "the name" String name;</programlisting>
        </listitem>
        
        </itemizedlist>
                        
        </section>
        
        <section>
            <title>Annotation types</title>
            
            <para>The annotation type of an annotation must be a subtype of the interface 
            <literal>ConstrainedAnnotation</literal> defined in the package 
            <literal>ceylon.language.metamodel</literal>. Any type which is a subtype of 
            <literal>ConstrainedAnnotation</literal> is called an <emphasis>annotation 
            type</emphasis>.</para>
            
            <programlisting><![CDATA[shared interface ConstrainedAnnotation<out Value, out Values, in ProgramElement>
        of OptionalAnnotation<Value,ProgramElement> | SequencedAnnotation<Value,ProgramElement>
        satisfies Annotation<Value>
        given Value satisfies Annotation<Value>
        given ProgramElement satisfies Annotated {
    shared Boolean occurs(Annotated programElement) {
        return programElement is ProgramElement;
    }
}]]></programlisting>
        
            <para>The type arguments of this interface express constraints upon how 
            annotations which return the annotation type occur.</para> 
            
            <para>There are only two direct subtypes of <literal>ConstrainedAnnotation</literal>:</para>
            
            <programlisting><![CDATA[shared interface OptionalAnnotation<out Value, in ProgramElement>
        satisfies ConstrainedAnnotation<Value,Value?,ProgramElement>
        given Value satisfies Annotation<Value>
        given ProgramElement satisfies Annotated {}]]></programlisting>
               
            <programlisting><![CDATA[shared interface SequencedAnnotation<out T, in ProgramElement>
        satisfies ConstrainedAnnotation<Value,Value[],ProgramElement>
        given Value satisfies Annotation<Value>
        given ProgramElement satisfies Annotated {}]]></programlisting>
            
            <para>If <literal>A</literal> is an annotation type then:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If <literal>A</literal> is a subtype of <literal>OptionalAnnotation</literal>,
                    at most one annotation of annotation type <literal>A</literal> may occur 
                    at a given program element.</para>
                </listitem>
                <listitem>
                    <para>If <literal>A</literal> is a subtype of <literal>SequencedAnnotation</literal>,
                    multiple annotations of annotation type <literal>A</literal> may occur 
                    at a given program element.</para>
                </listitem>
                <listitem>
                    <para>If <literal>A</literal> is a subtype of <literal>OptionalAnnotation&lt;A,P&gt;</literal>,
                    or <literal>SequencedAnnotation&lt;A,P&gt;</literal> then an annotation 
                    of annotation type <literal>A</literal> may not occur at a program element
                    whose metamodel expression type is not assignable to <literal>P</literal>.</para>
                </listitem>
            </itemizedlist>
                        
            <programlisting><![CDATA[shared interface Scope
        of request | session | application
        satisfies OptionalAnnotation<Scope,Type<Object>> {}]]></programlisting>
            
            <programlisting><![CDATA[shared class Todo(String text)
        satisfies SequencedAnnotation<Todo,Annotated> {
    shared actual String string = text;
}]]></programlisting>
            
            <para>It is perfectly acceptable for multiple toplevel methods to return the same 
            annotation type.</para>
            
            <comment><para>TODO: should we let an annotation return multiple instances of an
            annotation type (<literal>A[]</literal> where <literal>A</literal> is an annotation
            type).</para></comment>
            
        </section>
        
        <section>
            <title>Annotation values</title>
            
            <para>An <emphasis>annotation value</emphasis> is the value returned when an
            annotation is evaluated. We may obtain the annotation values of all annotations
            of a given annotation type that occur at a given program element by passing the 
            annotation type and program element metamodel reference to the method
            <literal>annotations()</literal> defined in the package
            <literal>ceylon.language.metamodel</literal>.</para>
            
            <programlisting>Scope scope = annotations(Scope, Person) ? request;</programlisting>
            <programlisting>Todo[] todos = annotations(Todo, method);</programlisting>
            
        </section>
        
    </section>
    
    <section id="declarationmodifiers">
        <title>Declaration modifiers</title>
                
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>shared</literal> specifies that a 
                declaration is visible outside of the package or body in 
                which it occurs, or that a package is visible outside the
                module it belongs to.</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated.</para>
            </listitem>
             <listitem>
                <para><literal>formal</literal> specifies that a member 
                does not specify an implementation and must therefore be 
                refined by every concrete subclass.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be refined by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>actual</literal> indicates that a method,
                attribute, or member type refines a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>variable</literal> specifies that an attribute
                or local may be assigned.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument. The compiler produces a
                warning when compiling code that depends upon a deprecated
                program element.</para>
            </listitem>
            <!--
            <listitem>
                <para><literal>definite</literal> specifies that a method or
                attribute must be refined by every concrete subclass. 
                <emphasis>(Note that <literal>definite</literal> is a proposed 
                feature for a future version of the language.)</emphasis></para>
            </listitem>
            -->
            <!-- 
            <listitem>
                <para><literal>final</literal> specifies that a class may not 
                be extended.</para>
            </listitem>
             -->
            <listitem>
                <para><literal>literal</literal> specifies that a class or 
                interface has a single quoted literal format.</para>
            </listitem>
        </itemizedlist>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Integer</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Integer</literal> and <literal>Float</literal> 
        are assumed to represent 64-bit values.</para>
        
        <comment><para>TODO: should we have <literal>final</literal> to specify 
        that a class may not be extended?</para></comment>
        
        <!--
        <comment><para>TODO: should we make <literal>actual</literal> a keyword, 
        to save the effort of redeclaring the attribute type or method return 
        type?</para></comment>
        -->
        
        <comment><para>TODO: how hard would it be to add a <literal>recursive</literal>
        annotation to force the compiler to optimize a tail-recursive method or
        getter?</para></comment>
               
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
    
    <section id="refinement">
        <title>Refinement modifiers</title>
        
        <para>A declaration may not be annotated both <literal>formal</literal> 
        and <literal>default</literal>. <!--<literal>definite</literal>.--></para>
        
        <para>If a declaration is annotated <literal>formal</literal>, 
        <literal>default</literal>, <!--<literal>definite</literal>,--> or 
        <literal>actual</literal> then it must also be annotated 
        <literal>shared</literal>.</para>
        
    </section>
    
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, methods, attributes, locals, parameters and type 
        parameters have names. Occurrence of a name in code implies a hard dependency 
        from the code in which the name occurs to the schema of the named declaration. 
        We say that a class, interface, method, attribute, parameter or type parameter 
        is <emphasis>visible</emphasis> to a certain program element if its name may 
        occur in the code that defines that program element.</para>
                
        <para>The visibility of a declaration depends upon where it occurs, and upon 
        whether it is annotated <literal>shared</literal>. A toplevel or member 
        declaration may be annotated <literal>shared</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>If a toplevel declaration is annotated <literal>shared</literal>, 
                it is visible wherever the package that contains it is visible.
                Otherwise, a toplevel declaration is visible only to code in the 
                package containing its compilation unit.</para>
            </listitem>
            <listitem>
                <para>If a member declaration is annotated <literal>shared</literal>, 
                it is visible wherever the class or interface that contains it is 
                visible. Otherwise, a declaration that occurs directly inside a class 
                or interface body is visible only inside the class or interface 
                declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A parameter, type parameter, or declaration that occurs directly inside
        a block (the body of a method, attribute getter or attribute setter) may not 
        be annotated <literal>shared</literal>.</para>
        
        <itemizedlist>
            <listitem>
                <para>A parameter or type parameter is visible only inside the 
                declaration to which it belongs.</para> 
            </listitem>
            <listitem>
                <para>A declaration that occurs directly inside a block is visible 
                only inside the block.</para>
            </listitem>
        </itemizedlist>
        
        <para>A nested declaration not annotated <literal>shared</literal> is called 
        a <emphasis>block local</emphasis> declaration.</para>
        
        <comment><para>TODO: Should we allow you to limit the effect of the 
        <literal>shared</literal> annotation by specifying a containing program 
        element or package? Program element is easy, since we already have a
        typesafe syntax for referring to a method or type: 
        <literal>shared(ContainingClass)</literal>. Package is a bit tricker.
        Of course we could use a single quoted literal, 
        <literal>shared('org.example.containing.package')</literal>, but perhaps 
        this would justify introducing a literal package name syntax:
        <literal>shared(:org:example:containing:package)</literal>.</para>
        </comment>
        
        <para>We say that a produced type is <emphasis>visible</emphasis> to a
        certain program element if it is formed from type parameters and types 
        whose declarations are visible to the program element. For 
        <literal>shared</literal> declarations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The type of an attribute must be visible everywhere the 
                attribute itself is visible.</para>
            </listitem>
            <listitem>
                <para>The return type of a method must be visible everywhere the 
                method itself is visible.</para>
            </listitem>
            <listitem>
                <para>The satisfied interfaces of a class or interface must be 
                visible everywhere the class or interface itself is visible.</para>
            </listitem>
            <listitem>
                <para>The superclass of a class must be visible everywhere the 
                class itself is visible.</para>
            </listitem>
        </itemizedlist>
        
    </section>
        
    <section id="documentation">
        <title>Documentation</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element, in Markdown format text.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>license</literal> specifies the URL of the
                license under which a module or package is distributed.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
            <listitem>
                <para><literal>tagged</literal> specifies classifying named 
                tags.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Markdown-format
        content.</para>
        
        <para>These annotations are defined in the package 
        <literal>ceylon.language.documentation</literal>.</para>
        
     </section>
        
     </section>

</chapter>
