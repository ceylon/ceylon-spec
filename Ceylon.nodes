"A file containing Ceylon source."
^(COMPILATION_UNIT
    MODULE_DESCRIPTOR?
    PACKAGE_DESCRIPTOR?
    COMPILER_ANNOTATION*
    IMPORT_LIST?
    DECLARATION*)

^(MODULE_DESCRIPTOR:STATEMENT_OR_ARGUMENT
    ANNOTATION_LIST?
    IMPORT_PATH
    QUOTED_LITERAL version
    IMPORT_MODULE_LIST)

^(PACKAGE_DESCRIPTOR:STATEMENT_OR_ARGUMENT
    ANNOTATION_LIST?
    IMPORT_PATH)

^(IMPORT_MODULE_LIST
    IMPORT_MODULE*)

^(IMPORT_MODULE:STATEMENT_OR_ARGUMENT
    ANNOTATION_LIST?
    IMPORT_PATH
    QUOTED_LITERAL version)

^(IMPORT_LIST 
    IMPORT*)

^(IMPORT:STATEMENT_OR_ARGUMENT
    IMPORT_PATH 
    IMPORT_MEMBER_OR_TYPE_LIST)

^(IMPORT_PATH 
    IDENTIFIER*
    Package packageModel;)

^(IMPORT_MEMBER_OR_TYPE_LIST
    IMPORT_MEMBER_OR_TYPE*
    IMPORT_WILDCARD?
    ImportList importList;)

^(IMPORT_MEMBER_OR_TYPE:STATEMENT_OR_ARGUMENT
    ALIAS?
    IDENTIFIER
    IMPORT_MEMBER_OR_TYPE_LIST?
    Declaration declarationModel;
    Import importModel;)
^(IMPORT_MEMBER:IMPORT_MEMBER_OR_TYPE)
^(IMPORT_TYPE:IMPORT_MEMBER_OR_TYPE)

^(ALIAS 
    IDENTIFIER)
^(IMPLICIT)
^(IMPORT_WILDCARD)

"A declaration."
^(abstract DECLARATION:STATEMENT
    ANNOTATION_LIST?
    IDENTIFIER
    abstract Declaration declarationModel;)

"A class, interface, or type parameter declaration."
^(abstract TYPE_DECLARATION:DECLARATION
    TYPE_PARAMETER_LIST?
    CASE_TYPES?
    SATISFIED_TYPES?
    abstract TypeDeclaration declarationModel;)

"A class or interface declaration."
^(abstract CLASS_OR_INTERFACE:TYPE_DECLARATION
    TYPE_CONSTRAINT_LIST?
    abstract ClassOrInterface declarationModel;)

^(SATISFIED_TYPES 
    SIMPLE_TYPE* type)
^(ABSTRACTED_TYPE 
    SIMPLE_TYPE type)
^(ADAPTED_TYPES 
    SIMPLE_TYPE* type)
^(CASE_TYPES 
    SIMPLE_TYPE* type
    BASE_MEMBER_EXPRESSION*)
^(EXTENDED_TYPE 
    SIMPLE_TYPE type
    INVOCATION_EXPRESSION)

"A list of constraints organized by parameter."
^(TYPE_CONSTRAINT_LIST 
    TYPE_CONSTRAINT*)

"A set of type constraints on a certain type parameter."
^(TYPE_CONSTRAINT:TYPE_DECLARATION
    PARAMETER_LIST? 
    ABSTRACTED_TYPE?
    TypeParameter declarationModel;)

^(TYPE_SPECIFIER 
    SIMPLE_TYPE type)

^(ANY_CLASS:CLASS_OR_INTERFACE
    PARAMETER_LIST
    EXTENDED_TYPE?
    Class declarationModel;)

^(CLASS_DEFINITION:ANY_CLASS
    CLASS_BODY)

^(CLASS_DECLARATION:ANY_CLASS
    TYPE_SPECIFIER?)

^(ANY_INTERFACE:CLASS_OR_INTERFACE
    Interface declarationModel;)

^(INTERFACE_DEFINITION:ANY_INTERFACE
    ADAPTED_TYPES?
    INTERFACE_BODY)

^(INTERFACE_DECLARATION:ANY_INTERFACE
    TYPE_SPECIFIER?)

^(abstract TYPED_DECLARATION:DECLARATION
    TYPE?
    abstract TypedDeclaration declarationModel;)

^(abstract ANY_ATTRIBUTE:TYPED_DECLARATION)

"A simple or formal attribute declaration."
^(ATTRIBUTE_DECLARATION:ANY_ATTRIBUTE 
    SPECIFIER_OR_INITIALIZER_EXPRESSION?
    Value declarationModel;)

"An attribute getter declaration."
^(ATTRIBUTE_GETTER_DEFINITION:ANY_ATTRIBUTE
    BLOCK
    Getter declarationModel;)

"An attribute setter declaration."
^(ATTRIBUTE_SETTER_DEFINITION:TYPED_DECLARATION
    BLOCK
    Setter declarationModel;)

"A method declaration."
^(ANY_METHOD:TYPED_DECLARATION
    TYPE_PARAMETER_LIST?
    PARAMETER_LIST*
    TYPE_CONSTRAINT_LIST?
    Method declarationModel;)
    
^(METHOD_DEFINITION:ANY_METHOD
    BLOCK)

^(METHOD_DECLARATION:ANY_METHOD
    SPECIFIER_EXPRESSION?)

^(VOID_MODIFIER:TYPE)

^(OBJECT_DEFINITION:TYPED_DECLARATION
    EXTENDED_TYPE?
    SATISFIED_TYPES?
    CLASS_BODY
    Value declarationModel;
    Class anonymousClass;)

^(PARAMETER_LIST 
    PARAMETER*)
^(abstract PARAMETER:TYPED_DECLARATION  
    DEFAULT_ARGUMENT?
    abstract Parameter declarationModel;)
^(DEFAULT_ARGUMENT SPECIFIER_EXPRESSION)
^(VALUE_PARAMETER_DECLARATION:PARAMETER
    ValueParameter declarationModel;)
^(FUNCTIONAL_PARAMETER_DECLARATION:PARAMETER
    PARAMETER_LIST*
    FunctionalParameter declarationModel;)

^(TYPE_PARAMETER_LIST 
    TYPE_PARAMETER_DECLARATION*)
^(TYPE_PARAMETER_DECLARATION:DECLARATION
    TYPE_VARIANCE?
    TypeParameter declarationModel;
    boolean sequenced;)
^(TYPE_VARIANCE)

^(abstract BODY
    STATEMENT*)

"A method or attribute body containing statements and declarations."
^(BLOCK:BODY
    boolean definitelyReturns;)

^(SYNTHETIC_BLOCK:BLOCK)

"A class body."
^(CLASS_BODY:BODY)

"An interface body."
^(INTERFACE_BODY:BODY)

^(abstract TYPE
    ProducedType typeModel;)

^(abstract STATIC_TYPE:TYPE)

"A produced type."
^(abstract SIMPLE_TYPE:STATIC_TYPE
    IDENTIFIER 
    TYPE_ARGUMENT_LIST?
    TypeDeclaration declarationModel;)

^(BASE_TYPE: SIMPLE_TYPE)

^(UNION_TYPE: STATIC_TYPE
    STATIC_TYPE*)

^(INTERSECTION_TYPE: STATIC_TYPE
    STATIC_TYPE*)

^(SEQUENCE_TYPE: STATIC_TYPE
    STATIC_TYPE elementType)

^(OPTIONAL_TYPE: STATIC_TYPE
    STATIC_TYPE definiteType)

^(FUNCTION_TYPE: STATIC_TYPE
    STATIC_TYPE returnType
    STATIC_TYPE* argumentType)

^(ENTRY_TYPE: STATIC_TYPE
    STATIC_TYPE keyType
    STATIC_TYPE valueType)

^(QUALIFIED_TYPE: SIMPLE_TYPE
    STATIC_TYPE outerType)

^(SUPER_TYPE: STATIC_TYPE)

"Specifies that the type of a block local declaration should be inferred."
^(abstract LOCAL_MODIFIER: TYPE)

"Specifies that the type of a local declaration should be inferred."
^(VALUE_MODIFIER: LOCAL_MODIFIER)

"Specifies that the type of a method declaration should be inferred."
^(FUNCTION_MODIFIER: LOCAL_MODIFIER)

^(SYNTHETIC_VARIABLE: VALUE_MODIFIER)

^(TYPE_ARGUMENTS
    List<ProducedType> typeModels;)

"A list of type arguments in a produced type."
^(TYPE_ARGUMENT_LIST:TYPE_ARGUMENTS
    TYPE*)

^(INFERRED_TYPE_ARGUMENTS:TYPE_ARGUMENTS)

^(SEQUENCED_TYPE:TYPE
    TYPE)

"A control directive."
^(abstract DIRECTIVE:EXECUTABLE_STATEMENT)
^(RETURN:DIRECTIVE EXPRESSION?
    Declaration declaration;)
^(THROW:DIRECTIVE EXPRESSION?)
^(CONTINUE:DIRECTIVE)
^(BREAK:DIRECTIVE)

^(abstract STATEMENT_OR_ARGUMENT
    COMPILER_ANNOTATION*)

"A statement or declaration."
^(abstract STATEMENT:STATEMENT_OR_ARGUMENT)

^(COMPILER_ANNOTATION
    IDENTIFIER
    STRING_LITERAL?)

"An expression statement, specification statement, or control structure."
^(abstract EXECUTABLE_STATEMENT:STATEMENT)

^(SPECIFIER_STATEMENT:EXECUTABLE_STATEMENT 
    TERM baseMemberExpression
    SPECIFIER_EXPRESSION
    boolean refinement;)

^(EXPRESSION_STATEMENT:EXECUTABLE_STATEMENT 
    EXPRESSION)

^(CONTROL_STATEMENT:EXECUTABLE_STATEMENT)
^(CONTROL_CLAUSE
    ControlBlock controlBlock;)

^(IF_STATEMENT:CONTROL_STATEMENT
    IF_CLAUSE
    ELSE_CLAUSE?)
^(IF_CLAUSE:CONTROL_CLAUSE
    CONDITION
    BLOCK)
^(ELSE_CLAUSE:CONTROL_CLAUSE
    BLOCK)

^(SWITCH_STATEMENT:CONTROL_STATEMENT
    SWITCH_CLAUSE
    SWITCH_CASE_LIST)
^(SWITCH_CLAUSE
    EXPRESSION)
^(SWITCH_CASE_LIST 
    CASE_CLAUSE* 
    ELSE_CLAUSE?)
^(CASE_CLAUSE:CONTROL_CLAUSE
    CASE_ITEM
    BLOCK)
    
^(CASE_ITEM)
^(MATCH_CASE:CASE_ITEM
    EXPRESSION_LIST)
^(IS_CASE:CASE_ITEM
    TYPE
    VARIABLE?)
^(SATISFIES_CASE:CASE_ITEM
    SIMPLE_TYPE type)

^(TRY_CATCH_STATEMENT:CONTROL_STATEMENT
    TRY_CLAUSE
    CATCH_CLAUSE* 
    FINALLY_CLAUSE?)
^(TRY_CLAUSE:CONTROL_CLAUSE
    RESOURCE? 
    BLOCK)
^(CATCH_CLAUSE:CONTROL_CLAUSE
    CATCH_VARIABLE 
    BLOCK)
^(FINALLY_CLAUSE:CONTROL_CLAUSE
    BLOCK)
^(RESOURCE
    VARIABLE? EXPRESSION?)
^(CATCH_VARIABLE
    VARIABLE)

^(FOR_STATEMENT:CONTROL_STATEMENT
    FOR_CLAUSE
    ELSE_CLAUSE?
    boolean exits;)
^(FOR_CLAUSE:CONTROL_CLAUSE
    FOR_ITERATOR
    BLOCK)
^(FOR_ITERATOR:STATEMENT_OR_ARGUMENT
    SPECIFIER_EXPRESSION)
^(VALUE_ITERATOR:FOR_ITERATOR
    VARIABLE)
^(KEY_VALUE_ITERATOR:FOR_ITERATOR
    VARIABLE keyVariable
    VARIABLE valueVariable)

^(WHILE_STATEMENT:CONTROL_STATEMENT
    WHILE_CLAUSE)
^(WHILE_CLAUSE:CONTROL_CLAUSE
    CONDITION
    BLOCK)

^(abstract CONDITION)
^(BOOLEAN_CONDITION:CONDITION
    EXPRESSION)
^(abstract EXISTS_OR_NONEMPTY_CONDITION:CONDITION
    VARIABLE
    EXPRESSION?)
^(EXISTS_CONDITION:EXISTS_OR_NONEMPTY_CONDITION)
^(NONEMPTY_CONDITION:EXISTS_OR_NONEMPTY_CONDITION)
^(IS_CONDITION:CONDITION
    TYPE
    VARIABLE
    EXPRESSION?)
^(SATISFIES_CONDITION:CONDITION
    TYPE leftType
    TYPE rightType)

^(VARIABLE:TYPED_DECLARATION
    PARAMETER_LIST*
    SPECIFIER_EXPRESSION?
    Value declarationModel;)

^(abstract TERM
    ProducedType typeModel;
    boolean unboxed;)
^(abstract OPERATOR_EXPRESSION:TERM)

^(abstract BINARY_OPERATOR_EXPRESSION:OPERATOR_EXPRESSION
    TERM leftTerm
    TERM rightTerm)

^(abstract ARITHMETIC_OP: BINARY_OPERATOR_EXPRESSION)
^(SUM_OP: ARITHMETIC_OP)
^(DIFFERENCE_OP: ARITHMETIC_OP)
^(PRODUCT_OP: ARITHMETIC_OP)
^(QUOTIENT_OP: ARITHMETIC_OP)
^(POWER_OP: ARITHMETIC_OP)
^(REMAINDER_OP: ARITHMETIC_OP)

^(abstract ASSIGNMENT_OP: BINARY_OPERATOR_EXPRESSION)
^(ASSIGN_OP: ASSIGNMENT_OP)

^(abstract ARITHMETIC_ASSIGNMENT_OP: ASSIGNMENT_OP)
^(ADD_ASSIGN_OP: ARITHMETIC_ASSIGNMENT_OP)
^(SUBTRACT_ASSIGN_OP: ARITHMETIC_ASSIGNMENT_OP)
^(MULTIPLY_ASSIGN_OP: ARITHMETIC_ASSIGNMENT_OP)
^(DIVIDE_ASSIGN_OP: ARITHMETIC_ASSIGNMENT_OP)
^(REMAINDER_ASSIGN_OP: ARITHMETIC_ASSIGNMENT_OP)

^(abstract BITWISE_ASSIGNMENT_OP: ASSIGNMENT_OP)
^(INTERSECT_ASSIGN_OP: BITWISE_ASSIGNMENT_OP)
^(UNION_ASSIGN_OP: BITWISE_ASSIGNMENT_OP)
^(XOR_ASSIGN_OP: BITWISE_ASSIGNMENT_OP)
^(COMPLEMENT_ASSIGN_OP: BITWISE_ASSIGNMENT_OP)

^(abstract LOGICAL_ASSIGNMENT_OP: ASSIGNMENT_OP)
^(AND_ASSIGN_OP: LOGICAL_ASSIGNMENT_OP)
^(OR_ASSIGN_OP: LOGICAL_ASSIGNMENT_OP)

^(abstract LOGICAL_OP: BINARY_OPERATOR_EXPRESSION)
^(AND_OP: LOGICAL_OP)
^(OR_OP: LOGICAL_OP)

^(abstract BITWISE_OP: BINARY_OPERATOR_EXPRESSION)
^(INTERSECTION_OP: BITWISE_OP)
^(UNION_OP: BITWISE_OP)
^(XOR_OP: BITWISE_OP)
^(COMPLEMENT_OP: BITWISE_OP)

^(abstract EQUALITY_OP: BINARY_OPERATOR_EXPRESSION)
^(EQUAL_OP: EQUALITY_OP)
^(NOT_EQUAL_OP: EQUALITY_OP)

^(abstract COMPARISON_OP: BINARY_OPERATOR_EXPRESSION)
^(LARGER_OP: COMPARISON_OP)
^(SMALLER_OP: COMPARISON_OP)
^(LARGE_AS_OP: COMPARISON_OP)
^(SMALL_AS_OP: COMPARISON_OP)

^(DEFAULT_OP: BINARY_OPERATOR_EXPRESSION)
^(THEN_OP: BINARY_OPERATOR_EXPRESSION)
^(IDENTICAL_OP: BINARY_OPERATOR_EXPRESSION)
^(ENTRY_OP: BINARY_OPERATOR_EXPRESSION)
^(RANGE_OP: BINARY_OPERATOR_EXPRESSION)
^(SEGMENT_OP: BINARY_OPERATOR_EXPRESSION)
^(COMPARE_OP: BINARY_OPERATOR_EXPRESSION)
^(IN_OP: BINARY_OPERATOR_EXPRESSION)

^(abstract UNARY_OPERATOR_EXPRESSION:OPERATOR_EXPRESSION
    TERM)

^(NOT_OP: UNARY_OPERATOR_EXPRESSION)
^(EXISTS: UNARY_OPERATOR_EXPRESSION)
^(NONEMPTY: UNARY_OPERATOR_EXPRESSION)
^(NEGATIVE_OP: UNARY_OPERATOR_EXPRESSION)
^(POSITIVE_OP: UNARY_OPERATOR_EXPRESSION)

^(abstract TYPE_OPERATOR_EXPRESSION: UNARY_OPERATOR_EXPRESSION
    TYPE)
^(IS_OP: TYPE_OPERATOR_EXPRESSION)
^(SATISFIES: TYPE_OPERATOR_EXPRESSION)
^(EXTENDS: TYPE_OPERATOR_EXPRESSION)

^(abstract PREFIX_OPERATOR_EXPRESSION: UNARY_OPERATOR_EXPRESSION)
^(INCREMENT_OP: PREFIX_OPERATOR_EXPRESSION)
^(DECREMENT_OP: PREFIX_OPERATOR_EXPRESSION)

"A postfix increment or decrement expression."
^(abstract POSTFIX_OPERATOR_EXPRESSION: UNARY_OPERATOR_EXPRESSION)
^(POSTFIX_INCREMENT_OP: POSTFIX_OPERATOR_EXPRESSION)
^(POSTFIX_DECREMENT_OP: POSTFIX_OPERATOR_EXPRESSION)

"A parenthesized list of expressions."
^(EXPRESSION_LIST 
    EXPRESSION*)

"An expression."
^(EXPRESSION:ATOM 
    TERM)

"The receiver of a member reference or invocation expression."
^(abstract PRIMARY:TERM)
^(abstract POSTFIX_EXPRESSION:PRIMARY
    PRIMARY)

"An invocation expression. Note that in the special case of 
inline callable arguments, there may be more than one
argument list."
^(INVOCATION_EXPRESSION:POSTFIX_EXPRESSION
    POSITIONAL_ARGUMENT_LIST? 
    NAMED_ARGUMENT_LIST?)

^(SYNTHETIC_INVOCATION_EXPRESSION:INVOCATION_EXPRESSION)

^(abstract MEMBER_OR_TYPE_EXPRESSION:PRIMARY
    ProducedReference target;
    Declaration declaration;
    List<ProducedType> signature;
    boolean directlyInvoked;
    boolean assigned;)

^(EXTENDED_TYPE_EXPRESSION:MEMBER_OR_TYPE_EXPRESSION)

^(abstract STATIC_MEMBER_OR_TYPE_EXPRESSION:MEMBER_OR_TYPE_EXPRESSION
    IDENTIFIER
    TYPE_ARGUMENTS?)

^(abstract BASE_MEMBER_OR_TYPE_EXPRESSION:STATIC_MEMBER_OR_TYPE_EXPRESSION)

"A reference to a member in an expression."
^(BASE_MEMBER_EXPRESSION:BASE_MEMBER_OR_TYPE_EXPRESSION)

"A reference to a type in an expression."
^(BASE_TYPE_EXPRESSION:BASE_MEMBER_OR_TYPE_EXPRESSION)

^(abstract QUALIFIED_MEMBER_OR_TYPE_EXPRESSION:STATIC_MEMBER_OR_TYPE_EXPRESSION
    PRIMARY
    MEMBER_OPERATOR)

"A qualified member reference expression."
^(QUALIFIED_MEMBER_EXPRESSION:QUALIFIED_MEMBER_OR_TYPE_EXPRESSION)

"A qualified member type reference expression."
^(QUALIFIED_TYPE_EXPRESSION:QUALIFIED_MEMBER_OR_TYPE_EXPRESSION)

^(abstract MEMBER_OPERATOR)
^(MEMBER_OP: MEMBER_OPERATOR)
^(SAFE_MEMBER_OP: MEMBER_OPERATOR)
^(SPREAD_OP: MEMBER_OPERATOR)

"An index (element access by key) expression."
^(INDEX_EXPRESSION:POSTFIX_EXPRESSION
    INDEX_OPERATOR
    ELEMENT_OR_RANGE)

^(abstract INDEX_OPERATOR)
^(INDEX_OP: INDEX_OPERATOR)
^(SAFE_INDEX_OP: INDEX_OPERATOR)

^(abstract ELEMENT_OR_RANGE)
^(ELEMENT:ELEMENT_OR_RANGE
    EXPRESSION)
^(ELEMENT_RANGE:ELEMENT_OR_RANGE
    EXPRESSION lowerBound
    EXPRESSION? upperBound
    EXPRESSION? length)

^(OUTER:ATOM)

"A list of arguments in an invocation expression."
^(abstract ARGUMENT_LIST)

"A list of named arguments."
^(NAMED_ARGUMENT_LIST:ARGUMENT_LIST 
    NAMED_ARGUMENT*
    SEQUENCED_ARGUMENT?
    COMPREHENSION?
    NamedArgumentList namedArgumentList;)

^(SEQUENCED_ARGUMENT:STATEMENT_OR_ARGUMENT
    EXPRESSION_LIST
    ELLIPSIS?
    Parameter parameter;)

"A list of positional arguments."
^(POSITIONAL_ARGUMENT_LIST:ARGUMENT_LIST 
    POSITIONAL_ARGUMENT*
    COMPREHENSION?
    ELLIPSIS?)

^(ELLIPSIS)

^(POSITIONAL_ARGUMENT 
    EXPRESSION
    Parameter parameter;)
    
^(FUNCTION_ARGUMENT: TERM
    TYPE type
    PARAMETER_LIST*
    EXPRESSION
    Method declarationModel;)

^(abstract NAMED_ARGUMENT:STATEMENT_OR_ARGUMENT
    IDENTIFIER
    Parameter parameter;)
^(SPECIFIED_ARGUMENT:NAMED_ARGUMENT
    SPECIFIER_EXPRESSION)
^(abstract TYPED_ARGUMENT:NAMED_ARGUMENT
    TYPE
    abstract TypedDeclaration declarationModel;)
^(METHOD_ARGUMENT:TYPED_ARGUMENT
    PARAMETER_LIST*
    BLOCK
    Method declarationModel;)
^(ATTRIBUTE_ARGUMENT:TYPED_ARGUMENT
    BLOCK
    Getter declarationModel;)
^(OBJECT_ARGUMENT:TYPED_ARGUMENT
    EXTENDED_TYPE?
    SATISFIED_TYPES?
    CLASS_BODY
    Value declarationModel;
    Class anonymousClass;)

^(abstract SPECIFIER_OR_INITIALIZER_EXPRESSION EXPRESSION)

"A specifier expression."
^(SPECIFIER_EXPRESSION:SPECIFIER_OR_INITIALIZER_EXPRESSION)

"An initializer expression."
^(INITIALIZER_EXPRESSION:SPECIFIER_OR_INITIALIZER_EXPRESSION)

^(SYNTHETIC_SPECIFIER_EXPRESSION:SPECIFIER_EXPRESSION)

"A member reference, type reference, literal, string template, or parenthesized expression."
^(abstract ATOM:PRIMARY)

"A literal."
^(abstract LITERAL:ATOM)
^(NATURAL_LITERAL:LITERAL)
^(FLOAT_LITERAL:LITERAL)
^(CHAR_LITERAL:LITERAL)
^(STRING_LITERAL:LITERAL)
^(QUOTED_LITERAL:LITERAL)

"A reference to the current instance."
^(abstract SELF_EXPRESSION:ATOM)
^(THIS:SELF_EXPRESSION)
^(SUPER:SELF_EXPRESSION)

"Enumerated elements of a sequence."
^(SEQUENCE_ENUMERATION:ATOM 
    SEQUENCED_ARGUMENT?
    COMPREHENSION?)

"A string template."
^(STRING_TEMPLATE:ATOM 
    STRING_LITERAL* 
    EXPRESSION*)

^(LAMBDA:ATOM
    PARAMETER_LIST
    BLOCK)

"A program element annotation."
^(ANNOTATION:INVOCATION_EXPRESSION)

"A list of annotations of a program element."
^(ANNOTATION_LIST 
    ANNOTATION*)

"A name."
^(IDENTIFIER)

^(COMPREHENSION:STATEMENT_OR_ARGUMENT
    FOR_COMPREHENSION_CLAUSE)

^(abstract COMPREHENSION_CLAUSE:CONTROL_CLAUSE
    ProducedType typeModel;)

^(EXPRESSION_COMPREHENSION_CLAUSE:COMPREHENSION_CLAUSE
    EXPRESSION)

^(FOR_COMPREHENSION_CLAUSE:COMPREHENSION_CLAUSE
    FOR_ITERATOR
    COMPREHENSION_CLAUSE)

^(IF_COMPREHENSION_CLAUSE:COMPREHENSION_CLAUSE
    CONDITION?
    COMPREHENSION_CLAUSE)
